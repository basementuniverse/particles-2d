/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/canvas-helpers/build/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@basementuniverse/canvas-helpers/build/index.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse { var i, a; }\n})(self, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./node_modules/@basementuniverse/utils/utils.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/@basementuniverse/utils/utils.js ***!\n  \\*******************************************************/\n/***/ ((module) => {\n\neval(\"/**\\n * @overview A library of useful functions\\n * @author Gordon Larrigan\\n */\\n\\n/**\\n * Memoize a function\\n * @param {Function} f The function to memoize\\n * @returns {Function} A memoized version of the function\\n */\\nconst memoize = f => {\\n  var cache = {};\\n  return function(...args) {\\n    return cache[args] ?? (cache[args] = f.apply(this, args));\\n  };\\n};\\n\\n/**\\n * Check if two numbers are approximately equal\\n * @param {number} a Number a\\n * @param {number} b Number b\\n * @param {number} [p=Number.EPSILON] The precision value\\n * @return {boolean} True if numbers a and b are approximately equal\\n */\\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\\n\\n/**\\n * Clamp a number between min and max\\n * @param {number} a The number to clamp\\n * @param {number} [min=0] The minimum value\\n * @param {number} [max=1] The maximum value\\n * @return {number} A clamped number\\n */\\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\\n\\n/**\\n * Get the fractional part of a number\\n * @param {number} a The number from which to get the fractional part\\n * @return {number} The fractional part of the number\\n */\\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\\n\\n/**\\n * Round n to d decimal places\\n * @param {number} n The number to round\\n * @param {number} [d=0] The number of decimal places to round to\\n * @return {number} A rounded number\\n */\\nconst round = (n, d = 0) => {\\n  const p = Math.pow(10, d);\\n  return Math.round(n * p + Number.EPSILON) / p;\\n}\\n\\n/**\\n * Do a linear interpolation between a and b\\n * @param {number} a The minimum number\\n * @param {number} b The maximum number\\n * @param {number} i The interpolation value, should be in the interval [0, 1]\\n * @return {number} An interpolated value in the interval [a, b]\\n */\\nconst lerp = (a, b, i) => a + (b - a) * i;\\n\\n/**\\n * Get the position of i between a and b\\n * @param {number} a The minimum number\\n * @param {number} b The maximum number\\n * @param {number} i The interpolated value in the interval [a, b]\\n * @return {number} The position of i between a and b\\n */\\nconst unlerp = (a, b, i) => (i - a) / (b - a);\\n\\n/**\\n * Do a bilinear interpolation\\n * @param {number} c00 Top-left value\\n * @param {number} c10 Top-right value\\n * @param {number} c01 Bottom-left value\\n * @param {number} c11 Bottom-right value\\n * @param {number} ix Interpolation value along x\\n * @param {number} iy Interpolation value along y\\n * @return {number} A bilinear interpolated value\\n */\\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\\n\\n/**\\n * Re-map a number i from range a1...a2 to b1...b2\\n * @param {number} i The number to re-map\\n * @param {number} a1\\n * @param {number} a2\\n * @param {number} b1\\n * @param {number} b2\\n * @return {number}\\n */\\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\\n\\n/**\\n * Do a smooth interpolation between a and b\\n * @param {number} a The minimum number\\n * @param {number} b The maximum number\\n * @param {number} i The interpolation value\\n * @return {number} An interpolated value in the interval [a, b]\\n */\\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\\n\\n/**\\n * Get an angle in radians\\n * @param {number} degrees The angle in degrees\\n * @return {number} The angle in radians\\n */\\nconst radians = degrees => (Math.PI / 180) * degrees;\\n\\n/**\\n * Get an angle in degrees\\n * @param {number} radians The angle in radians\\n * @return {number} The angle in degrees\\n */\\nconst degrees = radians => (180 / Math.PI) * radians;\\n\\n/**\\n * Get a random float in the interval [min, max)\\n * @param {number} min Inclusive min\\n * @param {number} max Exclusive max\\n * @return {number} A random float in the interval [min, max)\\n */\\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\\n\\n/**\\n * Get a random integer in the interval [min, max]\\n * @param {number} min Inclusive min\\n * @param {number} max Inclusive max\\n * @return {number} A random integer in the interval [min, max]\\n */\\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\\n\\n/**\\n * Get a normally-distributed random number\\n * @param {number} [mu=0.5] The mean value\\n * @param {number} [sigma=0.5] The standard deviation\\n * @param {number} [samples=2] The number of samples\\n * @return {number} A normally-distributed random number\\n */\\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\\n  let total = 0;\\n  for (let i = samples; i--;) {\\n    total += Math.random();\\n  }\\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\\n};\\n\\n/**\\n * Get a normally-distributed random integer in the interval [min, max]\\n * @param {number} min Inclusive min\\n * @param {number} max Inclusive max\\n * @return {number} A normally-distributed random integer\\n */\\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\\n\\n/**\\n * Return a weighted random integer\\n * @param {Array<number>} w An array of weights\\n * @return {number} An index from w\\n */\\nconst weightedRandom = w => {\\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\\n  const r = Math.random() * total;\\n  while (total > r) {\\n    total -= w[n++];\\n  }\\n  return n - 1;\\n};\\n\\n/**\\n * An interpolation function\\n * @callback InterpolationFunction\\n * @param {number} a The minimum number\\n * @param {number} b The maximum number\\n * @param {number} i The interpolation value, should be in the interval [0, 1]\\n * @return {number} The interpolated value in the interval [a, b]\\n */\\n\\n/**\\n * Return an interpolated value from an array\\n * @param {Array<number>} a An array of values interpolate\\n * @param {number} i A number in the interval [0, 1]\\n * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use\\n * @return {number} An interpolated value in the interval [min(a), max(a)]\\n */\\nconst lerpArray = (a, i, f = lerp) => {\\n  const s = i * (a.length - 1);\\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\\n};\\n\\n/**\\n * Get the dot product of two vectors\\n * @param {Array<number>} a Vector a\\n * @param {Array<number>} b Vector b\\n * @return {number} a ∙ b\\n */\\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\\n\\n/**\\n * Get the factorial of a number\\n * @param {number} a\\n * @return {number} a!\\n */\\nconst factorial = a => {\\n  let result = 1;\\n  for (let i = 2; i <= a; i++) {\\n    result *= i;\\n  }\\n  return result;\\n};\\n\\n/**\\n * Get the number of permutations of r elements from a set of n elements\\n * @param {number} n\\n * @param {number} r\\n * @return {number} nPr\\n */\\nconst npr = (n, r) => factorial(n) / factorial(n - r);\\n\\n/**\\n * Get the number of combinations of r elements from a set of n elements\\n * @param {number} n\\n * @param {number} r\\n * @return {number} nCr\\n */\\nconst ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\\n\\n/**\\n * Generate all permutations of r elements from an array\\n *\\n * @example\\n * ```js\\n * permutations([1, 2, 3], 2);\\n * ```\\n *\\n * Output:\\n * ```json\\n * [\\n *   [1, 2],\\n *   [1, 3],\\n *   [2, 1],\\n *   [2, 3],\\n *   [3, 1],\\n *   [3, 2]\\n * ]\\n * ```\\n * @param {Array<*>} a\\n * @param {number} r The number of elements to choose in each permutation\\n * @return {Array<Array<*>>} An array of permutation arrays\\n */\\nconst permutations = (a, r) => {\\n  if (r === 1) {\\n    return a.map(item => [item]);\\n  }\\n\\n  return a.reduce(\\n    (acc, item, i) => [\\n      ...acc,\\n      ...permutations(a.slice(0, i).concat(a.slice(i + 1)), r - 1).map(c => [item, ...c]),\\n    ],\\n    []\\n  );\\n}\\n\\n/**\\n * Generate all combinations of r elements from an array\\n *\\n * @example\\n * ```js\\n * combinations([1, 2, 3], 2);\\n * ```\\n *\\n * Output:\\n * ```json\\n * [\\n *   [1, 2],\\n *   [1, 3],\\n *   [2, 3]\\n * ]\\n * ```\\n * @param {Array<*>} a\\n * @param {number} r The number of elements to choose in each combination\\n * @return {Array<Array<*>>} An array of combination arrays\\n */\\nconst combinations = (a, r) => {\\n  if (r === 1) {\\n    return a.map(item => [item]);\\n  }\\n\\n  return a.reduce(\\n    (acc, item, i) => [\\n      ...acc,\\n      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),\\n    ],\\n    []\\n  );\\n};\\n\\n/**\\n * Get a cartesian product of arrays\\n *\\n * @example\\n * ```js\\n * cartesian([1, 2, 3], ['a', 'b']);\\n * ```\\n *\\n * Output:\\n * ```json\\n * [\\n *   [1, \\\"a\\\"],\\n *   [1, \\\"b\\\"],\\n *   [2, \\\"a\\\"],\\n *   [2, \\\"b\\\"],\\n *   [3, \\\"a\\\"],\\n *   [3, \\\"b\\\"]\\n * ]\\n * ```\\n */\\nconst cartesian = (...arr) =>\\n  arr.reduce(\\n    (a, b) => a.flatMap(c => b.map(d => [...c, d])),\\n    [[]]\\n  );\\n\\n/**\\n * A function for generating array values\\n * @callback TimesFunction\\n * @param {number} i The array index\\n * @return {*} The array value\\n */\\n\\n/**\\n * Return a new array with length n by calling function f(i) on each element\\n * @param {TimesFunction} f\\n * @param {number} n The size of the array\\n * @return {Array<*>}\\n */\\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\\n\\n/**\\n * Return an array containing numbers 0->(n - 1)\\n * @param {number} n The size of the array\\n * @return {Array<number>} An array of integers 0->(n - 1)\\n */\\nconst range = n => times(i => i, n);\\n\\n/**\\n * Zip multiple arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\\n * @param {...Array<*>} a The arrays to zip\\n * @return {Array<Array<*>>}\\n */\\nconst zip = (...a) => times(i => a.map(a => a[i]), Math.max(...a.map(a => a.length)));\\n\\n/**\\n * Return array[i] with positive and negative wrapping\\n * @param {Array<*>} a The array to access\\n * @param {number} i The positively/negatively wrapped array index\\n * @return {*} An element from the array\\n */\\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\\n\\n/**\\n * Return the last element of an array without removing it\\n * @param {Array<*>} a\\n * @return {*} The last element from the array\\n */\\nconst peek = (a) => {\\n  if (!a.length) {\\n    return undefined;\\n  }\\n\\n  return a[a.length - 1];\\n};\\n\\n/**\\n * Return the index for a given position in an unrolled 2d array\\n * @param {number} x The x position\\n * @param {number} y The y position\\n * @param {number} w The width of the 2d array\\n * @returns {number} The index in the unrolled array\\n */\\nconst ind = (x, y, w) => x + y * w;\\n\\n/**\\n * Return the position for a given index in an unrolled 2d array\\n * @param {number} i The index\\n * @param {number} w The width of the 2d array\\n * @returns {Array<number>} The position as a 2-tuple\\n */\\nconst pos = (i, w) => [i % w, Math.floor(i / w)];\\n\\n/**\\n * Chop an array into chunks of size n\\n * @param {Array<*>} a\\n * @param {number} n The chunk size\\n * @return {Array<Array<*>>} An array of array chunks\\n */\\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\\n\\n/**\\n * Randomly shuffle a shallow copy of an array\\n * @param {Array<*>} a\\n * @return {Array<*>} The shuffled array\\n */\\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\\n\\n/**\\n * Flatten an object\\n * @param {object} o\\n * @param {string} concatenator The string to use for concatenating keys\\n * @return {object} A flattened object\\n */\\nconst flat = (o, concatenator = '.') => {\\n  return Object.keys(o).reduce((acc, key) => {\\n    if (o[key] instanceof Date) {\\n      return {\\n        ...acc,\\n        [key]: o[key].toISOString(),\\n      };\\n    }\\n\\n    if (typeof o[key] !== 'object' || !o[key]) {\\n      return {\\n        ...acc,\\n        [key]: o[key],\\n      };\\n    }\\n    const flattened = flat(o[key], concatenator);\\n\\n    return {\\n      ...acc,\\n      ...Object.keys(flattened).reduce(\\n        (childAcc, childKey) => ({\\n          ...childAcc,\\n          [`${key}${concatenator}${childKey}`]: flattened[childKey],\\n        }),\\n        {}\\n      ),\\n    };\\n  }, {});\\n};\\n\\n/**\\n * Unflatten an object\\n * @param {object} o\\n * @param {string} concatenator The string to check for in concatenated keys\\n * @return {object} An un-flattened object\\n */\\nconst unflat = (o, concatenator = '.') => {\\n  let result = {}, temp, substrings, property, i;\\n\\n  for (property in o) {\\n    substrings = property.split(concatenator);\\n    temp = result;\\n    for (i = 0; i < substrings.length - 1; i++) {\\n      if (!(substrings[i] in temp)) {\\n        if (isFinite(substrings[i + 1])) {\\n          temp[substrings[i]] = [];\\n        } else {\\n          temp[substrings[i]] = {};\\n        }\\n      }\\n      temp = temp[substrings[i]];\\n    }\\n    temp[substrings[substrings.length - 1]] = o[property];\\n  }\\n\\n  return result;\\n};\\n\\n/**\\n * A split predicate\\n * @callback SplitPredicate\\n * @param {any} value The current value\\n * @return {boolean} True if the array should split at this index\\n */\\n\\n/**\\n * Split an array into sub-arrays based on a predicate\\n * @param {Array<*>} array\\n * @param {SplitPredicate} predicate\\n * @return {Array<Array<*>>} An array of arrays\\n */\\nconst split = (array, predicate) => {\\n  const result = [];\\n  let current = [];\\n  for (const value of array) {\\n    if (predicate(value)) {\\n      if (current.length) {\\n        result.push(current);\\n      }\\n      current = [value];\\n    } else {\\n      current.push(value);\\n    }\\n  }\\n  result.push(current);\\n\\n  return result;\\n};\\n\\n/**\\n * Pluck keys from an object\\n * @param {object} o\\n * @param {...string} keys The keys to pluck from the object\\n * @return {object} An object containing the plucked keys\\n */\\nconst pluck = (o, ...keys) => {\\n  return keys.reduce(\\n    (result, key) => Object.assign(result, { [key]: o[key] }),\\n    {}\\n  );\\n};\\n\\n/**\\n * Exclude keys from an object\\n * @param {object} o\\n * @param {...string} keys The keys to exclude from the object\\n * @return {object} An object containing all keys except excluded keys\\n */\\nconst exclude = (o, ...keys) => {\\n  return Object.fromEntries(\\n    Object.entries(o).filter(([key]) => !keys.includes(key))\\n  );\\n};\\n\\nif (true) {\\n  module.exports = {\\n    memoize,\\n    floatEquals,\\n    clamp,\\n    frac,\\n    round,\\n    lerp,\\n    unlerp,\\n    blerp,\\n    remap,\\n    smoothstep,\\n    radians,\\n    degrees,\\n    randomBetween,\\n    randomIntBetween,\\n    cltRandom,\\n    cltRandomInt,\\n    weightedRandom,\\n    lerpArray,\\n    dot,\\n    factorial,\\n    npr,\\n    ncr,\\n    permutations,\\n    combinations,\\n    cartesian,\\n    times,\\n    range,\\n    zip,\\n    at,\\n    peek,\\n    ind,\\n    pos,\\n    chunk,\\n    shuffle,\\n    flat,\\n    unflat,\\n    split,\\n    pluck,\\n    exclude,\\n  };\\n}\\n\\n\\n//# sourceURL=webpack://@basementuniverse/canvas-helpers/./node_modules/@basementuniverse/utils/utils.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@basementuniverse/vec/vec.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/@basementuniverse/vec/vec.js ***!\n  \\***************************************************/\n/***/ ((module) => {\n\neval(\"/**\\n * @overview A small vector and matrix library\\n * @author Gordon Larrigan\\n */\\n\\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\\n\\n/**\\n * A 2d vector\\n * @typedef {Object} vec2\\n * @property {number} x The x component of the vector\\n * @property {number} y The y component of the vector\\n */\\n\\n/**\\n * Create a new 2d vector\\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\\n * @param {number} [y] The y component of the vector\\n * @return {vec2} A new 2d vector\\n * @example <caption>various ways to initialise a vector</caption>\\n * let a = vec2(3, 2); // (3, 2)\\n * let b = vec2(4);    // (4, 4)\\n * let c = vec2(a);    // (3, 2)\\n * let d = vec2();     // (0, 0)\\n */\\nconst vec2 = (x, y) => {\\n  if (!x && !y) {\\n    return { x: 0, y: 0 };\\n  }\\n  if (_vec_is_vec2(x)) {\\n    return { x: x.x || 0, y: x.y || 0 };\\n  }\\n  return { x: x, y: y ?? x };\\n};\\n\\n/**\\n * Get the components of a vector as an array\\n * @param {vec2} a The vector to get components from\\n * @return {Array<number>} The vector components as an array\\n */\\nvec2.components = a => [a.x, a.y];\\n\\n/**\\n * Create a vector from an array of components\\n * @param {Array<number>} components The components of the vector\\n * @return {vec2} A new vector\\n */\\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\\n\\n/**\\n * Return a unit vector (1, 0)\\n * @return {vec2} A unit vector (1, 0)\\n */\\nvec2.ux = () => vec2(1, 0);\\n\\n/**\\n * Return a unit vector (0, 1)\\n * @return {vec2} A unit vector (0, 1)\\n */\\nvec2.uy = () => vec2(0, 1);\\n\\n/**\\n * Add vectors\\n * @param {vec2} a Vector a\\n * @param {vec2|number} b Vector or scalar b\\n * @return {vec2} a + b\\n */\\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\\n\\n/**\\n * Subtract vectors\\n * @param {vec2} a Vector a\\n * @param {vec2|number} b Vector or scalar b\\n * @return {vec2} a - b\\n */\\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\\n\\n/**\\n * Scale a vector\\n * @param {vec2} a Vector a\\n * @param {vec2|number} b Vector or scalar b\\n * @return {vec2} a * b\\n */\\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\\n\\n/**\\n * Scale a vector by a scalar, alias for vec2.mul\\n * @param {vec2} a Vector a\\n * @param {number} b Scalar b\\n * @return {vec2} a * b\\n */\\nvec2.scale = (a, b) => vec2.mul(a, b);\\n\\n/**\\n * Divide a vector\\n * @param {vec2} a Vector a\\n * @param {vec2|number} b Vector or scalar b\\n * @return {vec2} a / b\\n */\\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\\n\\n/**\\n * Get the length of a vector\\n * @param {vec2} a Vector a\\n * @return {number} |a|\\n */\\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\\n\\n/**\\n * Get the length of a vector using taxicab geometry\\n * @param {vec2} a Vector a\\n * @return {number} |a|\\n */\\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\\n\\n/**\\n * Normalise a vector\\n * @param {vec2} a The vector to normalise\\n * @return {vec2} ^a\\n */\\nvec2.nor = a => {\\n  let len = vec2.len(a);\\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\\n};\\n\\n/**\\n * Get a dot product of vectors\\n * @param {vec2} a Vector a\\n * @param {vec2} b Vector b\\n * @return {number} a ∙ b\\n */\\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\\n\\n/**\\n * Rotate a vector by r radians\\n * @param {vec2} a The vector to rotate\\n * @param {number} r The angle to rotate by, measured in radians\\n * @return {vec2} A rotated vector\\n */\\nvec2.rot = (a, r) => {\\n  let s = Math.sin(r),\\n    c = Math.cos(r);\\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\\n};\\n\\n/**\\n * Fast method to rotate a vector by -90, 90 or 180 degrees\\n * @param {vec2} a The vector to rotate\\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\\n * @return {vec2} A rotated vector\\n */\\nvec2.rotf = (a, r) => {\\n  switch (r) {\\n    case 1: return vec2(a.y, -a.x);\\n    case -1: return vec2(-a.y, a.x);\\n    case 2: case -2: return vec2(-a.x, -a.y);\\n    default: return a;\\n  }\\n};\\n\\n/**\\n * Scalar cross product of two vectors\\n * @param {vec2} a Vector a\\n * @param {vec2} b Vector b\\n * @return {number} a × b\\n */\\nvec2.cross = (a, b) => {\\n  return a.x * b.y - a.y * b.x;\\n};\\n\\n/**\\n * Check if two vectors are equal\\n * @param {vec2} a Vector a\\n * @param {vec2} b Vector b\\n * @return {boolean} True if vectors a and b are equal, false otherwise\\n */\\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\\n\\n/**\\n * Get the angle of a vector\\n * @param {vec2} a Vector a\\n * @return {number} The angle of vector a in radians\\n */\\nvec2.rad = a => Math.atan2(a.y, a.x);\\n\\n/**\\n * Copy a vector\\n * @param {vec2} a The vector to copy\\n * @return {vec2} A copy of vector a\\n */\\nvec2.cpy = a => vec2(a);\\n\\n/**\\n * A function to call on each component of a 2d vector\\n * @callback vec2MapCallback\\n * @param {number} value The component value\\n * @param {'x' | 'y'} label The component label (x or y)\\n * @return {number} The mapped component\\n */\\n\\n/**\\n * Call a function on each component of a vector and build a new vector from the results\\n * @param {vec2} a Vector a\\n * @param {vec2MapCallback} f The function to call on each component of the vector\\n * @return {vec2} Vector a mapped through f\\n */\\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\\n\\n/**\\n * Convert a vector into a string\\n * @param {vec2} a The vector to convert\\n * @param {string} [s=', '] The separator string\\n * @return {string} A string representation of the vector\\n */\\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\\n\\n/**\\n * Swizzle a vector with a string of component labels\\n *\\n * The string can contain:\\n * - `x` or `y`\\n * - `u` or `v` (aliases for `x` and `y`, respectively)\\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\\n * - `0` or `1` (these will be passed through unchanged)\\n * - `.` to return the component that would normally be at this position (or 0)\\n *\\n * Any other characters will default to 0\\n * @param {vec2} a The vector to swizzle\\n * @param {string} [s='..'] The swizzle string\\n * @return {Array<number>} The swizzled components\\n * @example <caption>swizzling a vector</caption>\\n * let a = vec2(3, -2);\\n * vec2.swiz(a, 'x');    // [3]\\n * vec2.swiz(a, 'yx');   // [-2, 3]\\n * vec2.swiz(a, 'xY');   // [3, 2]\\n * vec2.swiz(a, 'Yy');   // [2, -2]\\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\\n */\\nvec2.swiz = (a, s = '..') => {\\n  const result = [];\\n  s.split('').forEach((c, i) => {\\n    switch (c) {\\n      case 'x': case 'u': result.push(a.x); break;\\n      case 'y': case 'v': result.push(a.y); break;\\n      case 'X': case 'U': result.push(-a.x); break;\\n      case 'Y': case 'V': result.push(-a.y); break;\\n      case '0': result.push(0); break;\\n      case '1': result.push(1); break;\\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\\n      default: result.push(0);\\n    }\\n  });\\n  return result;\\n};\\n\\n/**\\n * Polar coordinates for a 2d vector\\n * @typedef {Object} polarCoordinates2d\\n * @property {number} r The magnitude (radius) of the vector\\n * @property {number} theta The angle of the vector\\n */\\n\\n/**\\n * Convert a vector into polar coordinates\\n * @param {vec2} a The vector to convert\\n * @return {polarCoordinates2d} The magnitude and angle of the vector\\n */\\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\\n\\n/**\\n * Convert polar coordinates into a vector\\n * @param {number} r The magnitude (radius) of the vector\\n * @param {number} theta The angle of the vector\\n * @return {vec2} A vector with the given angle and magnitude\\n */\\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\\n\\n/**\\n * A 3d vector\\n * @typedef {Object} vec3\\n * @property {number} x The x component of the vector\\n * @property {number} y The y component of the vector\\n * @property {number} z The z component of the vector\\n */\\n\\n/**\\n * Create a new 3d vector\\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\\n * @param {number} [z] The z component of the vector\\n * @return {vec3} A new 3d vector\\n * @example <caption>various ways to initialise a vector</caption>\\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\\n * let b = vec3(4, 5);          // (4, 5, 0)\\n * let c = vec3(6);             // (6, 6, 6)\\n * let d = vec3(a);             // (3, 2, 1)\\n * let e = vec3();              // (0, 0, 0)\\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\\n */\\nconst vec3 = (x, y, z) => {\\n  if (!x && !y && !z) {\\n    return { x: 0, y: 0, z: 0 };\\n  }\\n  if (_vec_is_vec3(x)) {\\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\\n  }\\n  if (_vec_is_vec2(x)) {\\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\\n  }\\n  return { x: x, y: y ?? x, z: z ?? x };\\n};\\n\\n/**\\n * Get the components of a vector as an array\\n * @param {vec3} a The vector to get components from\\n * @return {Array<number>} The vector components as an array\\n */\\nvec3.components = a => [a.x, a.y, a.z];\\n\\n/**\\n * Create a vector from an array of components\\n * @param {Array<number>} components The components of the vector\\n * @return {vec3} A new vector\\n */\\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\\n\\n/**\\n * Return a unit vector (1, 0, 0)\\n * @return {vec3} A unit vector (1, 0, 0)\\n */\\nvec3.ux = () => vec3(1, 0, 0);\\n\\n/**\\n * Return a unit vector (0, 1, 0)\\n * @return {vec3} A unit vector (0, 1, 0)\\n */\\nvec3.uy = () => vec3(0, 1, 0);\\n\\n/**\\n * Return a unit vector (0, 0, 1)\\n * @return {vec3} A unit vector (0, 0, 1)\\n */\\nvec3.uz = () => vec3(0, 0, 1);\\n\\n/**\\n * Add vectors\\n * @param {vec3} a Vector a\\n * @param {vec3|number} b Vector or scalar b\\n * @return {vec3} a + b\\n */\\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\\n\\n/**\\n * Subtract vectors\\n * @param {vec3} a Vector a\\n * @param {vec3|number} b Vector or scalar b\\n * @return {vec3} a - b\\n */\\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\\n\\n/**\\n * Scale a vector\\n * @param {vec3} a Vector a\\n * @param {vec3|number} b Vector or scalar b\\n * @return {vec3} a * b\\n */\\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\\n\\n/**\\n * Scale a vector by a scalar, alias for vec3.mul\\n * @param {vec3} a Vector a\\n * @param {number} b Scalar b\\n * @return {vec3} a * b\\n */\\nvec3.scale = (a, b) => vec3.mul(a, b);\\n\\n/**\\n * Divide a vector\\n * @param {vec3} a Vector a\\n * @param {vec3|number} b Vector or scalar b\\n * @return {vec3} a / b\\n */\\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\\n\\n/**\\n * Get the length of a vector\\n * @param {vec3} a Vector a\\n * @return {number} |a|\\n */\\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\\n\\n/**\\n * Get the length of a vector using taxicab geometry\\n * @param {vec3} a Vector a\\n * @return {number} |a|\\n */\\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\\n\\n/**\\n * Normalise a vector\\n * @param {vec3} a The vector to normalise\\n * @return {vec3} ^a\\n */\\nvec3.nor = a => {\\n  let len = vec3.len(a);\\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\\n};\\n\\n/**\\n * Get a dot product of vectors\\n * @param {vec3} a Vector a\\n * @param {vec3} b Vector b\\n * @return {number} a ∙ b\\n */\\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\\n\\n/**\\n * Rotate a vector using a rotation matrix\\n * @param {vec3} a The vector to rotate\\n * @param {mat} m The rotation matrix\\n * @return {vec3} A rotated vector\\n */\\nvec3.rot = (a, m) => vec3(\\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\\n);\\n\\n/**\\n * Rotate a vector by r radians around the x axis\\n * @param {vec3} a The vector to rotate\\n * @param {number} r The angle to rotate by, measured in radians\\n * @return {vec3} A rotated vector\\n */\\nvec3.rotx = (a, r) => vec3(\\n  a.x,\\n  a.y * Math.cos(r) - a.z * Math.sin(r),\\n  a.y * Math.sin(r) + a.z * Math.cos(r)\\n);\\n\\n/**\\n * Rotate a vector by r radians around the y axis\\n * @param {vec3} a The vector to rotate\\n * @param {number} r The angle to rotate by, measured in radians\\n * @return {vec3} A rotated vector\\n */\\nvec3.roty = (a, r) => vec3(\\n  a.x * Math.cos(r) + a.z * Math.sin(r),\\n  a.y,\\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\\n);\\n\\n/**\\n * Rotate a vector by r radians around the z axis\\n * @param {vec3} a The vector to rotate\\n * @param {number} r The angle to rotate by, measured in radians\\n * @return {vec3} A rotated vector\\n */\\nvec3.rotz = (a, r) => vec3(\\n  a.x * Math.cos(r) - a.y * Math.sin(r),\\n  a.x * Math.sin(r) + a.y * Math.cos(r),\\n  a.z\\n);\\n\\n/**\\n * Rotate a vector using a quaternion\\n * @param {vec3} a The vector to rotate\\n * @param {Array<number>} q The quaternion to rotate by\\n * @return {vec3} A rotated vector\\n */\\nvec3.rotq = (v, q) => {\\n  if (q.length !== 4) {\\n    return vec3();\\n  }\\n\\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\\n  if (d === 0) {\\n    return vec3();\\n  }\\n\\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\\n  const u = vec3(...uq.slice(0, 3));\\n  const s = uq[3];\\n  return vec3.add(\\n    vec3.add(\\n      vec3.mul(u, 2 * vec3.dot(u, v)),\\n      vec3.mul(v, s * s - vec3.dot(u, u))\\n    ),\\n    vec3.mul(vec3.cross(u, v), 2 * s)\\n  );\\n};\\n\\n/**\\n * Rotate a vector using Euler angles\\n * @param {vec3} a The vector to rotate\\n * @param {vec3} e The Euler angles to rotate by\\n * @return {vec3} A rotated vector\\n */\\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\\n\\n/**\\n * Get the cross product of vectors\\n * @param {vec3} a Vector a\\n * @param {vec3} b Vector b\\n * @return {vec3} a × b\\n */\\nvec3.cross = (a, b) => vec3(\\n  a.y * b.z - a.z * b.y,\\n  a.z * b.x - a.x * b.z,\\n  a.x * b.y - a.y * b.x\\n);\\n\\n/**\\n * Check if two vectors are equal\\n * @param {vec3} a Vector a\\n * @param {vec3} b Vector b\\n * @return {boolean} True if vectors a and b are equal, false otherwise\\n */\\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\\n\\n/**\\n * Get the angle of a vector from the x axis\\n * @param {vec3} a Vector a\\n * @return {number} The angle of vector a in radians\\n */\\nvec3.radx = a => Math.atan2(a.z, a.y);\\n\\n/**\\n * Get the angle of a vector from the y axis\\n * @param {vec3} a Vector a\\n * @return {number} The angle of vector a in radians\\n */\\nvec3.rady = a => Math.atan2(a.x, a.y);\\n\\n/**\\n * Get the angle of a vector from the z axis\\n * @param {vec3} a Vector a\\n * @return {number} The angle of vector a in radians\\n */\\nvec3.radz = a => Math.atan2(a.y, a.z);\\n\\n/**\\n * Copy a vector\\n * @param {vec3} a The vector to copy\\n * @return {vec3} A copy of vector a\\n */\\nvec3.cpy = a => vec3(a);\\n\\n/**\\n * A function to call on each component of a 3d vector\\n * @callback vec3MapCallback\\n * @param {number} value The component value\\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\\n * @return {number} The mapped component\\n */\\n\\n/**\\n * Call a function on each component of a vector and build a new vector from the results\\n * @param {vec3} a Vector a\\n * @param {vec3MapCallback} f The function to call on each component of the vector\\n * @return {vec3} Vector a mapped through f\\n */\\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\\n\\n/**\\n * Convert a vector into a string\\n * @param {vec3} a The vector to convert\\n * @param {string} [s=', '] The separator string\\n * @return {string} A string representation of the vector\\n */\\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\\n\\n/**\\n * Swizzle a vector with a string of component labels\\n *\\n * The string can contain:\\n * - `x`, `y` or `z`\\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\\n * - `0` or `1` (these will be passed through unchanged)\\n * - `.` to return the component that would normally be at this position (or 0)\\n *\\n * Any other characters will default to 0\\n * @param {vec3} a The vector to swizzle\\n * @param {string} [s='...'] The swizzle string\\n * @return {Array<number>} The swizzled components\\n * @example <caption>swizzling a vector</caption>\\n * let a = vec3(3, -2, 1);\\n * vec3.swiz(a, 'x');     // [3]\\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\\n */\\nvec3.swiz = (a, s = '...') => {\\n  const result = [];\\n  s.split('').forEach((c, i) => {\\n    switch (c) {\\n      case 'x': case 'u': case 'r': result.push(a.x); break;\\n      case 'y': case 'v': case 'g': result.push(a.y); break;\\n      case 'z': case 'w': case 'b': result.push(a.z); break;\\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\\n      case '0': result.push(0); break;\\n      case '1': result.push(1); break;\\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\\n      default: result.push(0);\\n    }\\n  });\\n  return result;\\n};\\n\\n/**\\n * Polar coordinates for a 3d vector\\n * @typedef {Object} polarCoordinates3d\\n * @property {number} r The magnitude (radius) of the vector\\n * @property {number} theta The tilt angle of the vector\\n * @property {number} phi The pan angle of the vector\\n */\\n\\n/**\\n * Convert a vector into polar coordinates\\n * @param {vec3} a The vector to convert\\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\\n */\\nvec3.polar = a => {\\n  let r = vec3.len(a),\\n    theta = Math.acos(a.y / r),\\n    phi = Math.atan2(a.z, a.x);\\n  return { r, theta, phi };\\n};\\n\\n/**\\n * Convert polar coordinates into a vector\\n * @param {number} r The magnitude (radius) of the vector\\n * @param {number} theta The tilt of the vector\\n * @param {number} phi The pan of the vector\\n * @return {vec3} A vector with the given angle and magnitude\\n */\\nvec3.fromPolar = (r, theta, phi) => {\\n  const sinTheta = Math.sin(theta);\\n  return vec3(\\n    r * sinTheta * Math.cos(phi),\\n    r * Math.cos(theta),\\n    r * sinTheta * Math.sin(phi)\\n  );\\n};\\n\\n/**\\n * A matrix\\n * @typedef {Object} mat\\n * @property {number} m The number of rows in the matrix\\n * @property {number} n The number of columns in the matrix\\n * @property {Array<number>} entries The matrix values\\n */\\n\\n/**\\n * Create a new matrix\\n * @param {number} [m=4] The number of rows\\n * @param {number} [n=4] The number of columns\\n * @param {Array<number>} [entries=[]] Matrix values in reading order\\n * @return {mat} A new matrix\\n */\\nconst mat = (m = 4, n = 4, entries = []) => ({\\n  m, n,\\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\\n});\\n\\n/**\\n * Get an identity matrix of size n\\n * @param {number} n The size of the matrix\\n * @return {mat} An identity matrix\\n */\\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\\n\\n/**\\n * Get an entry from a matrix\\n * @param {mat} a Matrix a\\n * @param {number} i The row offset\\n * @param {number} j The column offset\\n * @return {number} The value at position (i, j) in matrix a\\n */\\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\\n\\n/**\\n * Set an entry of a matrix\\n * @param {mat} a Matrix a\\n * @param {number} i The row offset\\n * @param {number} j The column offset\\n * @param {number} v The value to set in matrix a\\n */\\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\\n\\n/**\\n * Get a row from a matrix as an array\\n * @param {mat} a Matrix a\\n * @param {number} m The row offset\\n * @return {Array<number>} Row m from matrix a\\n */\\nmat.row = (a, m) => {\\n  const s = (m - 1) * a.n;\\n  return a.entries.slice(s, s + a.n);\\n};\\n\\n/**\\n * Get a column from a matrix as an array\\n * @param {mat} a Matrix a\\n * @param {number} n The column offset\\n * @return {Array<number>} Column n from matrix a\\n */\\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\\n\\n/**\\n * Add matrices\\n * @param {mat} a Matrix a\\n * @param {mat} b Matrix b\\n * @return {mat} a + b\\n */\\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\\n\\n/**\\n * Subtract matrices\\n * @param {mat} a Matrix a\\n * @param {mat} b Matrix b\\n * @return {mat} a - b\\n */\\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\\n\\n/**\\n * Multiply matrices\\n * @param {mat} a Matrix a\\n * @param {mat} b Matrix b\\n * @return {mat|false} ab or false if the matrices cannot be multiplied\\n */\\nmat.mul = (a, b) => {\\n  if (a.n !== b.m) { return false; }\\n  const result = mat(a.m, b.n);\\n  for (let i = 1; i <= a.m; i++) {\\n    for (let j = 1; j <= b.n; j++) {\\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\\n    }\\n  }\\n  return result;\\n};\\n\\n/**\\n * Multiply a matrix by a vector\\n * @param {mat} a Matrix a\\n * @param {vec2|vec3|number[]} b Vector b\\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\\n */\\nmat.mulv = (a, b) => {\\n  let n, bb, rt;\\n  if (_vec_is_vec3(b)) {\\n    bb = vec3.components(b);\\n    n = 3;\\n    rt = vec3.fromComponents;\\n  } else if (_vec_is_vec2(b)) {\\n    bb = vec2.components(b);\\n    n = 2;\\n    rt = vec2.fromComponents;\\n  } else {\\n    bb = b;\\n    n = b.length ?? 0;\\n    rt = v => v;\\n  }\\n  if (a.n !== n) { return false; }\\n  const result = [];\\n  for (let i = 1; i <= a.m; i++) {\\n    result.push(_vec_dot(mat.row(a, i), bb));\\n  }\\n  return rt(result);\\n}\\n\\n/**\\n * Scale a matrix\\n * @param {mat} a Matrix a\\n * @param {number} b Scalar b\\n * @return {mat} a * b\\n */\\nmat.scale = (a, b) => mat.map(a, v => v * b);\\n\\n/**\\n * Transpose a matrix\\n * @param {mat} a The matrix to transpose\\n * @return {mat} A transposed matrix\\n */\\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\\n\\n/**\\n * Get the minor of a matrix\\n * @param {mat} a Matrix a\\n * @param {number} i The row offset\\n * @param {number} j The column offset\\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\\n */\\nmat.minor = (a, i, j) => {\\n  if (a.m !== a.n) { return false; }\\n  const entries = [];\\n  for (let ii = 1; ii <= a.m; ii++) {\\n    if (ii === i) { continue; }\\n    for (let jj = 1; jj <= a.n; jj++) {\\n      if (jj === j) { continue; }\\n      entries.push(mat.get(a, ii, jj));\\n    }\\n  }\\n  return mat(a.m - 1, a.n - 1, entries);\\n};\\n\\n/**\\n * Get the determinant of a matrix\\n * @param {mat} a Matrix a\\n * @return {number|false} |a| or false if the matrix is not square\\n */\\nmat.det = a => {\\n  if (a.m !== a.n) { return false; }\\n  if (a.m === 1) {\\n    return a.entries[0];\\n  }\\n  if (a.m === 2) {\\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\\n  }\\n  let total = 0, sign = 1;\\n  for (let j = 1; j <= a.n; j++) {\\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\\n    sign *= -1;\\n  }\\n  return total;\\n};\\n\\n/**\\n * Normalise a matrix\\n * @param {mat} a The matrix to normalise\\n * @return {mat|false} ^a or false if the matrix is not square\\n */\\nmat.nor = a => {\\n  if (a.m !== a.n) { return false; }\\n  const d = mat.det(a);\\n  return mat.map(a, i => i * d);\\n};\\n\\n/**\\n * Get the adjugate of a matrix\\n * @param {mat} a The matrix from which to get the adjugate\\n * @return {mat} The adjugate of a\\n */\\nmat.adj = a => {\\n  const minors = mat(a.m, a.n);\\n  for (let i = 1; i <= a.m; i++) {\\n    for (let j = 1; j <= a.n; j++) {\\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\\n    }\\n  }\\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\\n  return mat.trans(cofactors);\\n};\\n\\n/**\\n * Get the inverse of a matrix\\n * @param {mat} a The matrix to invert\\n * @return {mat|false} a^-1 or false if the matrix has no inverse\\n */\\nmat.inv = a => {\\n  if (a.m !== a.n) { return false; }\\n  const d = mat.det(a);\\n  if (d === 0) { return false; }\\n  return mat.scale(mat.adj(a), 1 / d);\\n};\\n\\n/**\\n * Check if two matrices are equal\\n * @param {mat} a Matrix a\\n * @param {mat} b Matrix b\\n * @return {boolean} True if matrices a and b are identical, false otherwise\\n */\\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\\n\\n/**\\n * Copy a matrix\\n * @param {mat} a The matrix to copy\\n * @return {mat} A copy of matrix a\\n */\\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\\n\\n/**\\n * A function to call on each entry of a matrix\\n * @callback matrixMapCallback\\n * @param {number} value The entry value\\n * @param {number} index The entry index\\n * @param {Array<number>} entries The array of matrix entries\\n * @return {number} The mapped entry\\n */\\n\\n/**\\n * Call a function on each entry of a matrix and build a new matrix from the results\\n * @param {mat} a Matrix a\\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\\n * @return {mat} Matrix a mapped through f\\n */\\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\\n\\n/**\\n * Convert a matrix into a string\\n * @param {mat} a The matrix to convert\\n * @param {string} [ms=', '] The separator string for columns\\n * @param {string} [ns='\\\\n'] The separator string for rows\\n * @return {string} A string representation of the matrix\\n */\\nmat.str = (a, ms = ', ', ns = '\\\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\\n\\nif (true) {\\n  module.exports = { vec2, vec3, mat };\\n}\\n\\n\\n//# sourceURL=webpack://@basementuniverse/canvas-helpers/./node_modules/@basementuniverse/vec/vec.js?\");\n\n/***/ }),\n\n/***/ \"./index.ts\":\n/*!******************!*\\\n  !*** ./index.ts ***!\n  \\******************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nexports.clearPatternCache = clearPatternCache;\\nexports.withContext = withContext;\\nexports.line = line;\\nexports.cross = cross;\\nexports.arrow = arrow;\\nexports.circle = circle;\\nexports.rectangle = rectangle;\\nexports.polygon = polygon;\\nexports.path = path;\\nexports.grid = grid;\\nexports.image = image;\\nconst utils_1 = __webpack_require__(/*! @basementuniverse/utils */ \\\"./node_modules/@basementuniverse/utils/utils.js\\\");\\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \\\"./node_modules/@basementuniverse/vec/vec.js\\\");\\n// Pattern cache for performance optimization\\n// WeakMap keyed by image source, with values being Maps keyed by repeat mode\\nlet patternCache = new WeakMap();\\n/**\\n * Get or create a cached pattern for the given image and repeat mode\\n */\\nfunction getCachedPattern(context, image, repeatMode) {\\n    // Check if we have any patterns cached for this image\\n    let imagePatterns = patternCache.get(image);\\n    if (!imagePatterns) {\\n        imagePatterns = new Map();\\n        patternCache.set(image, imagePatterns);\\n    }\\n    // Check if we have a pattern cached for this repeat mode\\n    let pattern = imagePatterns.get(repeatMode);\\n    if (!pattern) {\\n        // Create and cache the pattern\\n        // Map pattern modes to canvas pattern repeat modes\\n        const canvasRepeatMode = repeatMode === 'pattern'\\n            ? 'repeat'\\n            : repeatMode === 'pattern-x'\\n                ? 'repeat-x'\\n                : repeatMode === 'pattern-y'\\n                    ? 'repeat-y'\\n                    : 'no-repeat';\\n        const newPattern = context.createPattern(image, canvasRepeatMode);\\n        if (newPattern) {\\n            imagePatterns.set(repeatMode, newPattern);\\n            pattern = newPattern;\\n        }\\n    }\\n    return pattern || null;\\n}\\n/**\\n * Clear the pattern cache for a specific image, or clear the entire cache\\n * if no image is specified. Useful for memory management.\\n */\\nfunction clearPatternCache(image) {\\n    if (image) {\\n        patternCache.delete(image);\\n    }\\n    else {\\n        patternCache = new WeakMap();\\n    }\\n}\\nconst DEFAULT_STYLE_OPTIONS = {\\n    batch: false,\\n    fill: false,\\n    fillColor: null,\\n    gradient: null,\\n    stroke: true,\\n    strokeColor: null,\\n    lineWidth: 1,\\n    lineStyle: 'solid',\\n    lineDash: null,\\n    crossStyle: 'x',\\n    rounded: false,\\n    arrow: {\\n        type: 'caret',\\n        size: 5,\\n    },\\n    pathType: 'linear',\\n    bezierOrder: 3,\\n    catmullRomTension: 0.5,\\n    rectangleAnchor: 'top-left',\\n};\\nconst DEFAULT_LINE_DASHES = {\\n    solid: [],\\n    dashed: [5, 5],\\n    dotted: [1, 3],\\n};\\nconst DEFAULT_IMAGE_OPTIONS = {\\n    fillMode: 'center',\\n    clip: false,\\n    repeatMode: 'no-repeat',\\n    opacity: 1,\\n    scale: 1,\\n    offset: (0, vec_1.vec2)(0, 0),\\n    offsetRelative: false,\\n};\\nconst DEFAULT_GRID_OPTIONS = {\\n    cellSize: 10,\\n};\\nconst BEZIER_MATRICES = {\\n    1: (0, vec_1.mat)(2, 2, [-1, 1, 1, 0]),\\n    2: (0, vec_1.mat)(3, 3, [1, -2, 1, -2, 2, 0, 1, 0, 0]),\\n    3: (0, vec_1.mat)(4, 4, [-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0]),\\n};\\nconst BEZIER_COEFFICIENTS = (t, order) => ({\\n    1: [t, 1],\\n    2: [t * t, t, 1],\\n    3: [t * t * t, t * t, t, 1],\\n}[order]);\\nconst CATMULL_ROM_BASIS_FUNCTIONS = [\\n    (t, tension) => -tension * Math.pow(t, 3) + 2 * tension * Math.pow(t, 2) - tension * t,\\n    (t, tension) => (2 - tension) * Math.pow(t, 3) + (tension - 3) * Math.pow(t, 2) + 1,\\n    (t, tension) => (tension - 2) * Math.pow(t, 3) +\\n        (3 - 2 * tension) * Math.pow(t, 2) +\\n        tension * t,\\n    (t, tension) => tension * Math.pow(t, 3) - tension * Math.pow(t, 2),\\n];\\nconst CATMULL_ROM_BASIS_VECTOR = (t, tension) => CATMULL_ROM_BASIS_FUNCTIONS.map(f => f(t, tension));\\n/**\\n * Type guard to check if a value is a Color object\\n */\\nfunction isColorObject(color) {\\n    return (typeof color === 'object' &&\\n        'r' in color &&\\n        'g' in color &&\\n        'b' in color &&\\n        (typeof color.a === 'number' || !('a' in color)));\\n}\\n/**\\n * Convert a color object to a string in the format \\\"rgba(r, g, b, a)\\\"\\n */\\nfunction colourToString(color) {\\n    var _a;\\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${(_a = color.a) !== null && _a !== void 0 ? _a : 1})`;\\n}\\n/**\\n * Prepare a color value (string or Color object) for use in styles\\n */\\nfunction prepareColor(color) {\\n    if (typeof color === 'string') {\\n        // Assume it's already a valid CSS color string\\n        return color;\\n    }\\n    else if (isColorObject(color)) {\\n        // Convert Color object to CSS color string\\n        return colourToString(color);\\n    }\\n    // If it's neither, default to black\\n    return 'black';\\n}\\n/**\\n * Prepare a gradient for use in styles\\n *\\n * Returns a CanvasGradient object or null if no gradient is specified\\n */\\nfunction prepareGradient(context, style) {\\n    if (!style) {\\n        return null;\\n    }\\n    let gradient;\\n    if (style.type === 'linear') {\\n        gradient = context.createLinearGradient(style.start.x, style.start.y, style.end.x, style.end.y);\\n    }\\n    else {\\n        gradient = context.createRadialGradient(style.start.x, style.start.y, 0, style.start.x, style.start.y, vec_1.vec2.len(vec_1.vec2.sub(style.end, style.start)) / 2);\\n    }\\n    for (const stop of style.colorStops) {\\n        gradient.addColorStop(stop.position, prepareColor(stop.color));\\n    }\\n    return gradient;\\n}\\n/**\\n * Get a complete style object with default values filled in\\n */\\nfunction getStyle(style) {\\n    var _a;\\n    return Object.assign({}, DEFAULT_STYLE_OPTIONS, {\\n        ...(style !== null && style !== void 0 ? style : {}),\\n        lineDash: style && style.lineDash !== undefined\\n            ? style.lineDash\\n            : (style === null || style === void 0 ? void 0 : style.lineStyle) === undefined\\n                ? []\\n                : DEFAULT_LINE_DASHES[(_a = style.lineStyle) !== null && _a !== void 0 ? _a : 'solid'],\\n        image: style && style.image !== undefined ? style.image : DEFAULT_IMAGE_OPTIONS,\\n        grid: style && style.grid !== undefined ? style.grid : DEFAULT_GRID_OPTIONS,\\n    });\\n}\\n/**\\n * Pass in a context and some number of functions that take a context as their\\n * first argument, and return an array of functions that don't require the\\n * context argument\\n *\\n * If only one function is passed, this will return a single function\\n */\\nfunction withContext(context, ...functions) {\\n    const result = functions.map(f => {\\n        return (...args) => {\\n            f(context, ...args);\\n        };\\n    });\\n    return result.length === 1 ? result[0] : result;\\n}\\n/**\\n * Draw a straight line segment between two points\\n */\\nfunction line(context, start, end, style) {\\n    context.save();\\n    // Apply styles\\n    const actualStyle = getStyle(style);\\n    if (actualStyle.strokeColor !== null) {\\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\\n    }\\n    if (actualStyle.lineWidth !== null) {\\n        context.lineWidth = actualStyle.lineWidth;\\n    }\\n    if (actualStyle.lineDash !== null) {\\n        context.setLineDash(actualStyle.lineDash);\\n    }\\n    // If this is a batch operation, don't begin a new path so we can add to any\\n    // existing path and draw multiple lines in one go\\n    if (!actualStyle.batch) {\\n        context.beginPath();\\n    }\\n    context.moveTo(start.x, start.y);\\n    context.lineTo(end.x, end.y);\\n    // Stroke the path if required\\n    // Additionally, if this is a batch operation, we don't stroke right away so\\n    // that we can add more lines to the same path if we want\\n    if (actualStyle.stroke && !actualStyle.batch) {\\n        context.stroke();\\n    }\\n    context.restore();\\n}\\n/**\\n * Draw a cross at a given position with a specified size\\n */\\nfunction cross(context, position, size, style) {\\n    context.save();\\n    // Apply styles\\n    const actualStyle = getStyle(style);\\n    if (actualStyle.strokeColor !== null) {\\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\\n    }\\n    if (actualStyle.lineWidth !== null) {\\n        context.lineWidth = actualStyle.lineWidth;\\n    }\\n    if (actualStyle.lineDash !== null) {\\n        context.setLineDash(actualStyle.lineDash);\\n    }\\n    // If this is a batch operation, don't begin a new path so we can add to any\\n    // existing path and draw multiple lines in one go\\n    if (!actualStyle.batch) {\\n        context.beginPath();\\n    }\\n    // Draw the cross\\n    const halfSize = size / 2;\\n    if (actualStyle.crossStyle === '+') {\\n        // Plus sign cross\\n        context.moveTo(position.x - halfSize, position.y);\\n        context.lineTo(position.x + halfSize, position.y);\\n        context.moveTo(position.x, position.y - halfSize);\\n        context.lineTo(position.x, position.y + halfSize);\\n    }\\n    else if (actualStyle.crossStyle === 'x') {\\n        // X cross\\n        context.moveTo(position.x - halfSize, position.y - halfSize);\\n        context.lineTo(position.x + halfSize, position.y + halfSize);\\n        context.moveTo(position.x - halfSize, position.y + halfSize);\\n        context.lineTo(position.x + halfSize, position.y - halfSize);\\n    }\\n    // Stroke the path if required\\n    if (actualStyle.stroke && !actualStyle.batch) {\\n        context.stroke();\\n    }\\n    context.restore();\\n}\\n/**\\n * Draw an arrow from a start point to an end point with an optional arrowhead\\n * at the end\\n *\\n * This function does not support batch drawing since it requires\\n * beginning a new path for the arrowhead\\n */\\nfunction arrow(context, start, end, style) {\\n    var _a, _b;\\n    context.save();\\n    // Apply styles\\n    const actualStyle = getStyle(style);\\n    if (actualStyle.strokeColor !== null) {\\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\\n    }\\n    if (actualStyle.lineWidth !== null) {\\n        context.lineWidth = actualStyle.lineWidth;\\n    }\\n    if (actualStyle.lineDash !== null) {\\n        context.setLineDash(actualStyle.lineDash);\\n    }\\n    // Arrows don't support batch drawing since we have to begin a new path\\n    // when drawing the arrowhead\\n    context.beginPath();\\n    // Draw the line segment\\n    context.moveTo(start.x, start.y);\\n    context.lineTo(end.x, end.y);\\n    context.stroke();\\n    // Draw the arrowhead if specified\\n    if (actualStyle.arrow) {\\n        const arrowSize = (_a = actualStyle.arrow.size) !== null && _a !== void 0 ? _a : 10;\\n        const halfSize = arrowSize / 2;\\n        const angle = vec_1.vec2.rad(vec_1.vec2.sub(end, start));\\n        const arrowType = (_b = actualStyle.arrow.type) !== null && _b !== void 0 ? _b : 'caret';\\n        context.save();\\n        context.translate(end.x, end.y);\\n        context.rotate(angle);\\n        if (typeof arrowType === 'function') {\\n            arrowType(context, arrowSize);\\n        }\\n        else if (arrowType === 'caret') {\\n            if (actualStyle.strokeColor !== null) {\\n                context.fillStyle = prepareColor(actualStyle.strokeColor);\\n            }\\n            context.beginPath();\\n            context.moveTo(0, -halfSize);\\n            context.lineTo(arrowSize, 0);\\n            context.lineTo(0, halfSize);\\n            context.closePath();\\n            context.fill();\\n        }\\n        else if (arrowType === 'chevron') {\\n            context.beginPath();\\n            context.moveTo(-halfSize, -halfSize);\\n            context.lineTo(0, 0);\\n            context.lineTo(-halfSize, halfSize);\\n            context.stroke();\\n        }\\n        context.restore();\\n    }\\n    context.restore();\\n}\\n/**\\n * Draw a circle at a specified center point with a given radius\\n */\\nfunction circle(context, center, radius, style) {\\n    context.save();\\n    // Apply styles\\n    const actualStyle = getStyle(style);\\n    if (actualStyle.fillColor !== null) {\\n        context.fillStyle = prepareColor(actualStyle.fillColor);\\n    }\\n    if (actualStyle.gradient) {\\n        const gradient = prepareGradient(context, actualStyle.gradient);\\n        if (gradient) {\\n            context.fillStyle = gradient;\\n        }\\n    }\\n    if (actualStyle.strokeColor !== null) {\\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\\n    }\\n    if (actualStyle.lineWidth !== null) {\\n        context.lineWidth = actualStyle.lineWidth;\\n    }\\n    if (actualStyle.lineDash !== null) {\\n        context.setLineDash(actualStyle.lineDash);\\n    }\\n    // If this is a batch operation, don't begin a new path so we can add to any\\n    // existing path and draw multiple shapes in one go\\n    if (!actualStyle.batch) {\\n        context.beginPath();\\n    }\\n    // Draw the circle\\n    context.arc(center.x, center.y, radius, 0, Math.PI * 2);\\n    // Fill the circle if required\\n    if (actualStyle.fill && !actualStyle.batch) {\\n        context.fill();\\n    }\\n    // Stroke the circle if required\\n    if (actualStyle.stroke && !actualStyle.batch) {\\n        context.stroke();\\n    }\\n    context.restore();\\n}\\n/**\\n * Draw a rectangle at a specified position with a given size\\n */\\nfunction rectangle(context, position, size, style) {\\n    var _a;\\n    context.save();\\n    // Apply styles\\n    const actualStyle = getStyle(style);\\n    if (actualStyle.fillColor !== null) {\\n        context.fillStyle = prepareColor(actualStyle.fillColor);\\n    }\\n    if (actualStyle.gradient) {\\n        const gradient = prepareGradient(context, actualStyle.gradient);\\n        if (gradient) {\\n            context.fillStyle = gradient;\\n        }\\n    }\\n    if (actualStyle.strokeColor !== null) {\\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\\n    }\\n    if (actualStyle.lineWidth !== null) {\\n        context.lineWidth = actualStyle.lineWidth;\\n    }\\n    if (actualStyle.lineDash !== null) {\\n        context.setLineDash(actualStyle.lineDash);\\n    }\\n    // If this is a batch operation, don't begin a new path so we can add to any\\n    // existing path and draw multiple shapes in one go\\n    if (!actualStyle.batch) {\\n        context.beginPath();\\n    }\\n    // Calculate anchor offset\\n    let anchor = actualStyle.rectangleAnchor || 'top-left';\\n    let offsetX = 0, offsetY = 0;\\n    switch (anchor) {\\n        case 'top-left':\\n            offsetX = 0;\\n            offsetY = 0;\\n            break;\\n        case 'top-center':\\n            offsetX = -size.x / 2;\\n            offsetY = 0;\\n            break;\\n        case 'top-right':\\n            offsetX = -size.x;\\n            offsetY = 0;\\n            break;\\n        case 'center-left':\\n            offsetX = 0;\\n            offsetY = -size.y / 2;\\n            break;\\n        case 'center':\\n            offsetX = -size.x / 2;\\n            offsetY = -size.y / 2;\\n            break;\\n        case 'center-right':\\n            offsetX = -size.x;\\n            offsetY = -size.y / 2;\\n            break;\\n        case 'bottom-left':\\n            offsetX = 0;\\n            offsetY = -size.y;\\n            break;\\n        case 'bottom-center':\\n            offsetX = -size.x / 2;\\n            offsetY = -size.y;\\n            break;\\n        case 'bottom-right':\\n            offsetX = -size.x;\\n            offsetY = -size.y;\\n            break;\\n    }\\n    const actualX = position.x + offsetX;\\n    const actualY = position.y + offsetY;\\n    // Draw the rectangle\\n    if (actualStyle.rounded) {\\n        context.roundRect(actualX, actualY, size.x, size.y, (_a = actualStyle.borderRadius) !== null && _a !== void 0 ? _a : 1);\\n    }\\n    else {\\n        context.rect(actualX, actualY, size.x, size.y);\\n    }\\n    // Fill the rectangle if required\\n    if (actualStyle.fill && !actualStyle.batch) {\\n        context.fill();\\n    }\\n    // Stroke the rectangle if required\\n    if (actualStyle.stroke && !actualStyle.batch) {\\n        context.stroke();\\n    }\\n    context.restore();\\n}\\n/**\\n * Draw a polygon defined by an array of vertices\\n */\\nfunction polygon(context, vertices, style) {\\n    if (vertices.length < 3) {\\n        return;\\n    }\\n    context.save();\\n    // Apply styles\\n    const actualStyle = getStyle(style);\\n    if (actualStyle.fillColor !== null) {\\n        context.fillStyle = prepareColor(actualStyle.fillColor);\\n    }\\n    if (actualStyle.gradient) {\\n        const gradient = prepareGradient(context, actualStyle.gradient);\\n        if (gradient) {\\n            context.fillStyle = gradient;\\n        }\\n    }\\n    if (actualStyle.strokeColor !== null) {\\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\\n    }\\n    if (actualStyle.lineWidth !== null) {\\n        context.lineWidth = actualStyle.lineWidth;\\n    }\\n    if (actualStyle.lineDash !== null) {\\n        context.setLineDash(actualStyle.lineDash);\\n    }\\n    // If this is a batch operation, don't begin a new path so we can add to any\\n    // existing path and draw multiple shapes in one go\\n    if (!actualStyle.batch) {\\n        context.beginPath();\\n    }\\n    // Draw the polygon path\\n    context.moveTo(vertices[0].x, vertices[0].y);\\n    for (let i = 1; i < vertices.length; i++) {\\n        context.lineTo(vertices[i].x, vertices[i].y);\\n    }\\n    context.closePath();\\n    // Fill the rectangle if required\\n    if (actualStyle.fill && !actualStyle.batch) {\\n        context.fill();\\n    }\\n    // Stroke the rectangle if required\\n    if (actualStyle.stroke && !actualStyle.batch) {\\n        context.stroke();\\n    }\\n    context.restore();\\n}\\n/**\\n * Draw a path defined by an array of vertices\\n */\\nfunction path(context, vertices, style) {\\n    var _a, _b;\\n    if (vertices.length < 2)\\n        return;\\n    context.save();\\n    // Apply styles\\n    const actualStyle = getStyle(style);\\n    if (actualStyle.strokeColor !== null) {\\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\\n    }\\n    if (actualStyle.lineWidth !== null) {\\n        context.lineWidth = actualStyle.lineWidth;\\n    }\\n    if (actualStyle.lineDash !== null) {\\n        context.setLineDash(actualStyle.lineDash);\\n    }\\n    // If this is a batch operation, don't begin a new path\\n    if (!actualStyle.batch) {\\n        context.beginPath();\\n    }\\n    // Handle different path types\\n    const pathType = actualStyle.pathType || 'linear';\\n    if (pathType === 'linear') {\\n        // Simple linear path\\n        context.moveTo(vertices[0].x, vertices[0].y);\\n        for (let i = 1; i < vertices.length; i++) {\\n            context.lineTo(vertices[i].x, vertices[i].y);\\n        }\\n    }\\n    else if (pathType === 'bezier') {\\n        const order = (0, utils_1.clamp)((_a = actualStyle.bezierOrder) !== null && _a !== void 0 ? _a : 3, 1, 3);\\n        // Draw bezier curve segments\\n        const segmentSize = order + 1;\\n        for (let i = 0; i + segmentSize <= vertices.length; i += order) {\\n            const segmentPoints = vertices.slice(i, i + segmentSize);\\n            // Draw first point of segment\\n            if (i === 0) {\\n                context.moveTo(segmentPoints[0].x, segmentPoints[0].y);\\n            }\\n            // Draw bezier curve through points\\n            for (let t = 0; t <= 1; t += 0.01) {\\n                const q = vec_1.mat.mulv(BEZIER_MATRICES[order], BEZIER_COEFFICIENTS(t, order));\\n                if (q === false) {\\n                    context.restore();\\n                    return;\\n                }\\n                let p = (0, vec_1.vec2)();\\n                for (let j = 0; j < segmentSize; j++) {\\n                    p.x += segmentPoints[j].x * q[j];\\n                    p.y += segmentPoints[j].y * q[j];\\n                }\\n                context.lineTo(p.x, p.y);\\n            }\\n        }\\n    }\\n    else if (pathType === 'catmull-rom') {\\n        const tension = (_b = actualStyle.catmullRomTension) !== null && _b !== void 0 ? _b : 0.5;\\n        // Need at least 4 points for Catmull-Rom\\n        if (vertices.length >= 4) {\\n            context.moveTo(vertices[1].x, vertices[1].y);\\n            // Draw curve segments\\n            for (let i = 1; i < vertices.length - 2; i++) {\\n                const points = [\\n                    vertices[i - 1],\\n                    vertices[i],\\n                    vertices[i + 1],\\n                    vertices[i + 2],\\n                ];\\n                for (let t = 0; t <= 1; t += 0.01) {\\n                    const x = (0, utils_1.dot)(points.map(p => p.x), CATMULL_ROM_BASIS_VECTOR(t, tension));\\n                    const y = (0, utils_1.dot)(points.map(p => p.y), CATMULL_ROM_BASIS_VECTOR(t, tension));\\n                    context.lineTo(x, y);\\n                }\\n            }\\n        }\\n        else {\\n            // Fall back to linear if not enough points\\n            context.moveTo(vertices[0].x, vertices[0].y);\\n            for (let i = 1; i < vertices.length; i++) {\\n                context.lineTo(vertices[i].x, vertices[i].y);\\n            }\\n        }\\n    }\\n    // Stroke the path if required\\n    if (actualStyle.stroke && !actualStyle.batch) {\\n        context.stroke();\\n    }\\n    context.restore();\\n}\\n/**\\n * Draw a grid of lines within a specified rectangular area\\n */\\nfunction grid(context, position, size, style) {\\n    // Get merged style options\\n    const actualStyle = getStyle(style);\\n    const gridOptions = actualStyle.grid;\\n    // Get cell size as vec2\\n    const cellSize = typeof gridOptions.cellSize === 'number'\\n        ? (0, vec_1.vec2)(gridOptions.cellSize, gridOptions.cellSize)\\n        : gridOptions.cellSize;\\n    context.save();\\n    // Apply line styles\\n    if (actualStyle.strokeColor !== null) {\\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\\n    }\\n    if (actualStyle.lineWidth !== null) {\\n        context.lineWidth = actualStyle.lineWidth;\\n    }\\n    if (actualStyle.lineDash !== null) {\\n        context.setLineDash(actualStyle.lineDash);\\n    }\\n    // Begin path if not batching\\n    if (!actualStyle.batch) {\\n        context.beginPath();\\n    }\\n    // Draw vertical lines\\n    const numVerticalLines = Math.floor(size.x / cellSize.x) + 1;\\n    for (let i = 0; i <= numVerticalLines; i++) {\\n        const x = position.x + i * cellSize.x;\\n        if (x <= position.x + size.x) {\\n            context.moveTo(x, position.y);\\n            context.lineTo(x, position.y + size.y);\\n        }\\n    }\\n    // Draw horizontal lines\\n    const numHorizontalLines = Math.floor(size.y / cellSize.y) + 1;\\n    for (let i = 0; i <= numHorizontalLines; i++) {\\n        const y = position.y + i * cellSize.y;\\n        if (y <= position.y + size.y) {\\n            context.moveTo(position.x, y);\\n            context.lineTo(position.x + size.x, y);\\n        }\\n    }\\n    // Stroke the grid if required\\n    if (actualStyle.stroke && !actualStyle.batch) {\\n        context.stroke();\\n    }\\n    context.restore();\\n}\\n/**\\n * Draw an image at a specified position, optionally scaling it to fit within\\n * a given rectangle\\n */\\nfunction image(context, image, position, size, style) {\\n    var _a, _b, _c, _d, _e;\\n    // Get merged style options\\n    const actualStyle = getStyle(style);\\n    const imageOptions = {\\n        ...DEFAULT_IMAGE_OPTIONS,\\n        ...((_a = actualStyle.image) !== null && _a !== void 0 ? _a : {}),\\n    };\\n    // Get natural image size\\n    let imageWidth, imageHeight;\\n    if ('width' in image && 'height' in image) {\\n        imageWidth = image.width;\\n        imageHeight = image.height;\\n    }\\n    else {\\n        throw new Error('Cannot determine image size');\\n    }\\n    // Rectangle to draw in\\n    const rectangleWidth = (_b = size === null || size === void 0 ? void 0 : size.x) !== null && _b !== void 0 ? _b : imageWidth;\\n    const rectangleHeight = (_c = size === null || size === void 0 ? void 0 : size.y) !== null && _c !== void 0 ? _c : imageHeight;\\n    // Calculate anchor offset for the rectangle\\n    let anchor = actualStyle.rectangleAnchor || 'top-left';\\n    let offsetX = 0, offsetY = 0;\\n    switch (anchor) {\\n        case 'top-left':\\n            offsetX = 0;\\n            offsetY = 0;\\n            break;\\n        case 'top-center':\\n            offsetX = -rectangleWidth / 2;\\n            offsetY = 0;\\n            break;\\n        case 'top-right':\\n            offsetX = -rectangleWidth;\\n            offsetY = 0;\\n            break;\\n        case 'center-left':\\n            offsetX = 0;\\n            offsetY = -rectangleHeight / 2;\\n            break;\\n        case 'center':\\n            offsetX = -rectangleWidth / 2;\\n            offsetY = -rectangleHeight / 2;\\n            break;\\n        case 'center-right':\\n            offsetX = -rectangleWidth;\\n            offsetY = -rectangleHeight / 2;\\n            break;\\n        case 'bottom-left':\\n            offsetX = 0;\\n            offsetY = -rectangleHeight;\\n            break;\\n        case 'bottom-center':\\n            offsetX = -rectangleWidth / 2;\\n            offsetY = -rectangleHeight;\\n            break;\\n        case 'bottom-right':\\n            offsetX = -rectangleWidth;\\n            offsetY = -rectangleHeight;\\n            break;\\n    }\\n    let dx = position.x + offsetX, dy = position.y + offsetY;\\n    // Compute draw size and position based on fillMode\\n    let sx = 0, sy = 0, sw = imageWidth, sh = imageHeight;\\n    let dw = imageWidth, dh = imageHeight;\\n    // Compute scale for fill modes\\n    switch (imageOptions.fillMode) {\\n        case 'stretch':\\n            dw = rectangleWidth;\\n            dh = rectangleHeight;\\n            break;\\n        case 'contain': {\\n            const scale = Math.min(rectangleWidth / imageWidth, rectangleHeight / imageHeight);\\n            dw = imageWidth * scale;\\n            dh = imageHeight * scale;\\n            break;\\n        }\\n        case 'fill': {\\n            const scale = Math.max(rectangleWidth / imageWidth, rectangleHeight / imageHeight);\\n            dw = imageWidth * scale;\\n            dh = imageHeight * scale;\\n            break;\\n        }\\n        case 'fit-x': {\\n            const scale = rectangleWidth / imageWidth;\\n            dw = imageWidth * scale;\\n            dh = imageHeight * scale;\\n            break;\\n        }\\n        case 'fit-y': {\\n            const scale = rectangleHeight / imageHeight;\\n            dw = imageWidth * scale;\\n            dh = imageHeight * scale;\\n            break;\\n        }\\n        case 'center':\\n        default:\\n            dw = imageWidth;\\n            dh = imageHeight;\\n            break;\\n    }\\n    // Apply scale option\\n    if (imageOptions.scale) {\\n        if (typeof imageOptions.scale === 'number') {\\n            dw *= imageOptions.scale;\\n            dh *= imageOptions.scale;\\n        }\\n        else {\\n            dw *= imageOptions.scale.x;\\n            dh *= imageOptions.scale.y;\\n        }\\n    }\\n    // Center image in rect for 'center', 'contain', 'fit-x', 'fit-y'\\n    if (imageOptions.fillMode !== 'stretch') {\\n        dx += (rectangleWidth - dw) / 2;\\n        dy += (rectangleHeight - dh) / 2;\\n    }\\n    // Apply offset\\n    if (imageOptions.offset) {\\n        if (imageOptions.offsetRelative) {\\n            dx += imageOptions.offset.x * rectangleWidth;\\n            dy += imageOptions.offset.y * rectangleHeight;\\n        }\\n        else {\\n            dx += imageOptions.offset.x;\\n            dy += imageOptions.offset.y;\\n        }\\n    }\\n    context.save();\\n    if (imageOptions.opacity !== undefined && imageOptions.opacity < 1) {\\n        context.globalAlpha *= imageOptions.opacity;\\n    }\\n    // Draw background rectangle if fill or stroke is requested\\n    if ((actualStyle.fill || actualStyle.stroke) &&\\n        (actualStyle.fillColor !== null || actualStyle.strokeColor !== null)) {\\n        rectangle(context, position, { x: rectangleWidth, y: rectangleHeight }, actualStyle);\\n    }\\n    // Clip if requested\\n    if (imageOptions.clip && size) {\\n        context.beginPath();\\n        // Support rounded corners if style.rounded and style.borderRadius is set\\n        const rounded = (_d = actualStyle.rounded) !== null && _d !== void 0 ? _d : false;\\n        const borderRadius = (_e = actualStyle.borderRadius) !== null && _e !== void 0 ? _e : 0;\\n        if (rounded && borderRadius > 0) {\\n            context.roundRect(position.x + offsetX, position.y + offsetY, rectangleWidth, rectangleHeight, borderRadius);\\n        }\\n        else {\\n            context.rect(position.x + offsetX, position.y + offsetY, rectangleWidth, rectangleHeight);\\n        }\\n        context.clip();\\n    }\\n    // Handle repeat modes\\n    if (imageOptions.repeatMode &&\\n        imageOptions.repeatMode !== 'no-repeat' &&\\n        size) {\\n        const repeatMode = imageOptions.repeatMode;\\n        // Use pattern-based rendering for pattern modes\\n        if (repeatMode === 'pattern' ||\\n            repeatMode === 'pattern-x' ||\\n            repeatMode === 'pattern-y') {\\n            const pattern = getCachedPattern(context, image, repeatMode);\\n            if (pattern) {\\n                context.save();\\n                // Calculate the scale factors\\n                const scaleX = dw / imageWidth;\\n                const scaleY = dh / imageHeight;\\n                // Apply transformation: translate to pattern origin, then scale\\n                context.translate(dx, dy);\\n                context.scale(scaleX, scaleY);\\n                context.fillStyle = pattern;\\n                // Fill the rectangle in the scaled coordinate system\\n                // We need to divide by the scale to get back to pattern coordinates\\n                const patternWidth = rectangleWidth / scaleX;\\n                const patternHeight = rectangleHeight / scaleY;\\n                const patternX = (position.x + offsetX - dx) / scaleX;\\n                const patternY = (position.y + offsetY - dy) / scaleY;\\n                context.fillRect(patternX, patternY, patternWidth, patternHeight);\\n                context.restore();\\n            }\\n        }\\n        // Use loop-based rendering for repeat modes\\n        else if (repeatMode === 'repeat' ||\\n            repeatMode === 'repeat-x' ||\\n            repeatMode === 'repeat-y') {\\n            const rectX = position.x + offsetX;\\n            const rectY = position.y + offsetY;\\n            // Calculate how many times the image repeats in each direction\\n            const repeatX = repeatMode === 'repeat' || repeatMode === 'repeat-x';\\n            const repeatY = repeatMode === 'repeat' || repeatMode === 'repeat-y';\\n            if (repeatX) {\\n                // Calculate how many tiles we need to cover the rectangle width\\n                // We need to go left from dx until we cover rectX, and right until we\\n                // cover rectX + rectangleWidth\\n                const tilesLeft = Math.ceil((dx - rectX) / dw);\\n                const tilesRight = Math.ceil((rectX + rectangleWidth - dx) / dw);\\n                for (let tileX = -tilesLeft; tileX < tilesRight; tileX++) {\\n                    const tileDrawX = dx + tileX * dw;\\n                    if (repeatY) {\\n                        // Calculate how many tiles we need to cover the rectangle height\\n                        const tilesUp = Math.ceil((dy - rectY) / dh);\\n                        const tilesDown = Math.ceil((rectY + rectangleHeight - dy) / dh);\\n                        for (let tileY = -tilesUp; tileY < tilesDown; tileY++) {\\n                            const tileDrawY = dy + tileY * dh;\\n                            context.drawImage(image, sx, sy, sw, sh, tileDrawX, tileDrawY, dw, dh);\\n                        }\\n                    }\\n                    else {\\n                        // Only repeat horizontally\\n                        context.drawImage(image, sx, sy, sw, sh, tileDrawX, dy, dw, dh);\\n                    }\\n                }\\n            }\\n            else if (repeatY) {\\n                // Only repeat vertically\\n                const tilesUp = Math.ceil((dy - rectY) / dh);\\n                const tilesDown = Math.ceil((rectY + rectangleHeight - dy) / dh);\\n                for (let tileY = -tilesUp; tileY < tilesDown; tileY++) {\\n                    const tileDrawY = dy + tileY * dh;\\n                    context.drawImage(image, sx, sy, sw, sh, dx, tileDrawY, dw, dh);\\n                }\\n            }\\n        }\\n    }\\n    else {\\n        // Draw the image\\n        context.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\\n    }\\n    context.restore();\\n}\\n\\n\\n//# sourceURL=webpack://@basementuniverse/canvas-helpers/./index.ts?\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_75763__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_75763__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module can't be inlined because the eval devtool is used.\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_75763__(\"./index.ts\");\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});\n\n//# sourceURL=webpack://@basementuniverse/particles-2d/./node_modules/@basementuniverse/canvas-helpers/build/index.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/intersection-helpers/build/2d/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@basementuniverse/intersection-helpers/build/2d/index.js ***!
  \*******************************************************************************/
/***/ (function(module) {

eval("!function(t,e){if(true)module.exports=e();else { var r, n; }}(this,(()=>{return t={395:t=>{const e=(t,e=0,n=1)=>t<e?e:t>n?n:t,n=t=>t>=0?t-Math.floor(t):t-Math.ceil(t),r=(t,e,n)=>t+(e-t)*n,s=(t=.5,e=.5,n=2)=>{let r=0;for(let t=n;t--;)r+=Math.random();return t+(r-n/2)/(n/2)*e},o=t=>{let e=1;for(let n=2;n<=t;n++)e*=n;return e},i=(t,e)=>1===e?t.map((t=>[t])):t.reduce(((n,r,s)=>[...n,...i(t.slice(0,s).concat(t.slice(s+1)),e-1).map((t=>[r,...t]))]),[]),c=(t,e)=>1===e?t.map((t=>[t])):t.reduce(((n,r,s)=>[...n,...c(t.slice(s+1),e-1).map((t=>[r,...t]))]),[]),a=(t,e)=>Array(e).fill(0).map(((e,n)=>t(n))),u=(t,e=\".\")=>Object.keys(t).reduce(((n,r)=>{if(t[r]instanceof Date)return{...n,[r]:t[r].toISOString()};if(\"object\"!=typeof t[r]||!t[r])return{...n,[r]:t[r]};const s=u(t[r],e);return{...n,...Object.keys(s).reduce(((t,n)=>({...t,[`${r}${e}${n}`]:s[n]})),{})}}),{});t.exports={memoize:t=>{var e={};return function(...n){return e[n]??(e[n]=t.apply(this,n))}},floatEquals:(t,e,n=Number.EPSILON)=>Math.abs(t-e)<n,clamp:e,frac:n,round:(t,e=0)=>{const n=Math.pow(10,e);return Math.round(t*n+Number.EPSILON)/n},lerp:r,unlerp:(t,e,n)=>(n-t)/(e-t),blerp:(t,e,n,s,o,i)=>r(r(t,e,o),r(n,s,o),i),remap:(t,e,n,r,s)=>r+(t-e)*(s-r)/(n-e),smoothstep:(t,e,n)=>r(t,e,3*Math.pow(n,2)-2*Math.pow(n,3)),radians:t=>Math.PI/180*t,degrees:t=>180/Math.PI*t,randomBetween:(t,e)=>Math.random()*(e-t)+t,randomIntBetween:(t,e)=>Math.floor(Math.random()*(e-t+1))+t,cltRandom:s,cltRandomInt:(t,e)=>Math.floor(t+s(.5,.5,2)*(e+1-t)),weightedRandom:t=>{let e=t.reduce(((t,e)=>t+e),0),n=0;const r=Math.random()*e;for(;e>r;)e-=t[n++];return n-1},lerpArray:(t,s,o=r)=>{const i=s*(t.length-1),c=e(Math.trunc(i),0,t.length-1);return o(t[c]||0,t[c+1]||0,n(i))},dot:(t,e)=>t.reduce(((t,n,r)=>t+n*e[r]),0),factorial:o,npr:(t,e)=>o(t)/o(t-e),ncr:(t,e)=>o(t)/(o(e)*o(t-e)),permutations:i,combinations:c,cartesian:(...t)=>t.reduce(((t,e)=>t.flatMap((t=>e.map((e=>[...t,e]))))),[[]]),times:a,range:t=>a((t=>t),t),zip:(...t)=>a((e=>t.map((t=>t[e]))),Math.max(...t.map((t=>t.length)))),at:(t,e)=>t[e<0?t.length-Math.abs(e+1)%t.length-1:e%t.length],peek:t=>{if(t.length)return t[t.length-1]},ind:(t,e,n)=>t+e*n,pos:(t,e)=>[t%e,Math.floor(t/e)],chunk:(t,e)=>a((n=>t.slice(n*e,n*e+e)),Math.ceil(t.length/e)),shuffle:t=>t.slice().sort((()=>Math.random()-.5)),flat:u,unflat:(t,e=\".\")=>{let n,r,s,o,i={};for(s in t){for(r=s.split(e),n=i,o=0;o<r.length-1;o++)r[o]in n||(isFinite(r[o+1])?n[r[o]]=[]:n[r[o]]={}),n=n[r[o]];n[r[r.length-1]]=t[s]}return i},split:(t,e)=>{const n=[];let r=[];for(const s of t)e(s)?(r.length&&n.push(r),r=[s]):r.push(s);return n.push(r),n},pluck:(t,...e)=>e.reduce(((e,n)=>Object.assign(e,{[n]:t[n]})),{}),exclude:(t,...e)=>Object.fromEntries(Object.entries(t).filter((([t])=>!e.includes(t))))}},430:t=>{const e=(t,e)=>Array(e).fill(0).map(((e,n)=>t(n))),n=(t,e)=>t.reduce(((t,n,r)=>t+n*e[r]),0),r=t=>\"object\"==typeof t&&\"x\"in t&&\"y\"in t,s=t=>\"object\"==typeof t&&\"x\"in t&&\"y\"in t&&\"z\"in t,o=(t,e)=>t||e?r(t)?{x:t.x||0,y:t.y||0}:{x:t,y:e??t}:{x:0,y:0};o.components=t=>[t.x,t.y],o.fromComponents=t=>o(...t.slice(0,2)),o.ux=()=>o(1,0),o.uy=()=>o(0,1),o.add=(t,e)=>({x:t.x+(e.x??e),y:t.y+(e.y??e)}),o.addm=(...t)=>t.reduce(((t,e)=>o.add(t,e)),o()),o.sub=(t,e)=>({x:t.x-(e.x??e),y:t.y-(e.y??e)}),o.subm=(...t)=>t.reduce(((t,e)=>o.sub(t,e))),o.mul=(t,e)=>({x:t.x*(e.x??e),y:t.y*(e.y??e)}),o.scale=(t,e)=>o.mul(t,e),o.div=(t,e)=>({x:t.x/(e.x??e),y:t.y/(e.y??e)}),o.len=t=>Math.sqrt(t.x*t.x+t.y*t.y),o.manhattan=t=>Math.abs(t.x)+Math.abs(t.y),o.nor=t=>{let e=o.len(t);return e?{x:t.x/e,y:t.y/e}:o()},o.dot=(t,e)=>t.x*e.x+t.y*e.y,o.rot=(t,e)=>{let n=Math.sin(e),r=Math.cos(e);return{x:r*t.x-n*t.y,y:n*t.x+r*t.y}},o.rotf=(t,e)=>{switch(e){case 1:return o(t.y,-t.x);case-1:return o(-t.y,t.x);case 2:case-2:return o(-t.x,-t.y);default:return t}},o.cross=(t,e)=>t.x*e.y-t.y*e.x,o.eq=(t,e)=>t.x===e.x&&t.y===e.y,o.rad=t=>Math.atan2(t.y,t.x),o.cpy=t=>o(t),o.map=(t,e)=>({x:e(t.x,\"x\"),y:e(t.y,\"y\")}),o.str=(t,e=\", \")=>`${t.x}${e}${t.y}`,o.swiz=(t,e=\"..\")=>{const n=[];return e.split(\"\").forEach(((e,r)=>{switch(e){case\"x\":case\"u\":n.push(t.x);break;case\"y\":case\"v\":n.push(t.y);break;case\"X\":case\"U\":n.push(-t.x);break;case\"Y\":case\"V\":n.push(-t.y);break;case\"0\":default:n.push(0);break;case\"1\":n.push(1);break;case\".\":n.push([t.x,t.y][r]??0)}})),n},o.polar=t=>({r:o.len(t),theta:Math.atan2(t.y,t.x)}),o.fromPolar=(t,e)=>o(t*Math.cos(e),t*Math.sin(e));const i=(t,e,n)=>t||e||n?s(t)?{x:t.x||0,y:t.y||0,z:t.z||0}:r(t)?{x:t.x||0,y:t.y||0,z:e||0}:{x:t,y:e??t,z:n??t}:{x:0,y:0,z:0};i.components=t=>[t.x,t.y,t.z],i.fromComponents=t=>i(...t.slice(0,3)),i.ux=()=>i(1,0,0),i.uy=()=>i(0,1,0),i.uz=()=>i(0,0,1),i.add=(t,e)=>({x:t.x+(e.x??e),y:t.y+(e.y??e),z:t.z+(e.z??e)}),i.addm=(...t)=>t.reduce(((t,e)=>i.add(t,e)),i()),i.sub=(t,e)=>({x:t.x-(e.x??e),y:t.y-(e.y??e),z:t.z-(e.z??e)}),i.subm=(...t)=>t.reduce(((t,e)=>i.sub(t,e))),i.mul=(t,e)=>({x:t.x*(e.x??e),y:t.y*(e.y??e),z:t.z*(e.z??e)}),i.scale=(t,e)=>i.mul(t,e),i.div=(t,e)=>({x:t.x/(e.x??e),y:t.y/(e.y??e),z:t.z/(e.z??e)}),i.len=t=>Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z),i.manhattan=t=>Math.abs(t.x)+Math.abs(t.y)+Math.abs(t.z),i.nor=t=>{let e=i.len(t);return e?{x:t.x/e,y:t.y/e,z:t.z/e}:i()},i.dot=(t,e)=>t.x*e.x+t.y*e.y+t.z*e.z,i.rot=(t,e)=>i(i.dot(i.fromComponents(c.row(e,1)),t),i.dot(i.fromComponents(c.row(e,2)),t),i.dot(i.fromComponents(c.row(e,3)),t)),i.rotx=(t,e)=>i(t.x,t.y*Math.cos(e)-t.z*Math.sin(e),t.y*Math.sin(e)+t.z*Math.cos(e)),i.roty=(t,e)=>i(t.x*Math.cos(e)+t.z*Math.sin(e),t.y,-t.x*Math.sin(e)+t.z*Math.cos(e)),i.rotz=(t,e)=>i(t.x*Math.cos(e)-t.y*Math.sin(e),t.x*Math.sin(e)+t.y*Math.cos(e),t.z),i.rotq=(t,e)=>{if(4!==e.length)return i();const n=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]+e[3]*e[3]);if(0===n)return i();const r=[e[0]/n,e[1]/n,e[2]/n,e[3]/n],s=i(...r.slice(0,3)),o=r[3];return i.add(i.add(i.mul(s,2*i.dot(s,t)),i.mul(t,o*o-i.dot(s,s))),i.mul(i.cross(s,t),2*o))},i.rota=(t,e)=>i.rotz(i.roty(i.rotx(t,e.x),e.y),e.z),i.cross=(t,e)=>i(t.y*e.z-t.z*e.y,t.z*e.x-t.x*e.z,t.x*e.y-t.y*e.x),i.eq=(t,e)=>t.x===e.x&&t.y===e.y&&t.z===e.z,i.radx=t=>Math.atan2(t.z,t.y),i.rady=t=>Math.atan2(t.x,t.y),i.radz=t=>Math.atan2(t.y,t.z),i.cpy=t=>i(t),i.map=(t,e)=>({x:e(t.x,\"x\"),y:e(t.y,\"y\"),z:e(t.z,\"z\")}),i.str=(t,e=\", \")=>`${t.x}${e}${t.y}${e}${t.z}`,i.swiz=(t,e=\"...\")=>{const n=[];return e.split(\"\").forEach(((e,r)=>{switch(e){case\"x\":case\"u\":case\"r\":n.push(t.x);break;case\"y\":case\"v\":case\"g\":n.push(t.y);break;case\"z\":case\"w\":case\"b\":n.push(t.z);break;case\"X\":case\"U\":case\"R\":n.push(-t.x);break;case\"Y\":case\"V\":case\"G\":n.push(-t.y);break;case\"Z\":case\"W\":case\"B\":n.push(-t.z);break;case\"0\":default:n.push(0);break;case\"1\":n.push(1);break;case\".\":n.push([t.x,t.y,t.z][r]??0)}})),n},i.polar=t=>{let e=i.len(t);return{r:e,theta:Math.acos(t.y/e),phi:Math.atan2(t.z,t.x)}},i.fromPolar=(t,e,n)=>{const r=Math.sin(e);return i(t*r*Math.cos(n),t*Math.cos(e),t*r*Math.sin(n))};const c=(t=4,e=4,n=[])=>({m:t,n:e,entries:n.concat(Array(t*e).fill(0)).slice(0,t*e)});c.identity=t=>c(t,t,Array(t*t).fill(0).map(((e,n)=>+(Math.floor(n/t)===n%t)))),c.get=(t,e,n)=>t.entries[n-1+(e-1)*t.n],c.set=(t,e,n,r)=>{t.entries[n-1+(e-1)*t.n]=r},c.row=(t,e)=>{const n=(e-1)*t.n;return t.entries.slice(n,n+t.n)},c.col=(t,n)=>e((e=>c.get(t,e+1,n)),t.m),c.add=(t,e)=>t.m===e.m&&t.n===e.n&&c.map(t,((t,n)=>t+e.entries[n])),c.sub=(t,e)=>t.m===e.m&&t.n===e.n&&c.map(t,((t,n)=>t-e.entries[n])),c.mul=(t,e)=>{if(t.n!==e.m)return!1;const r=c(t.m,e.n);for(let s=1;s<=t.m;s++)for(let o=1;o<=e.n;o++)c.set(r,s,o,n(c.row(t,s),c.col(e,o)));return r},c.mulv=(t,e)=>{let a,u,l;if(s(e)?(u=i.components(e),a=3,l=i.fromComponents):r(e)?(u=o.components(e),a=2,l=o.fromComponents):(u=e,a=e.length??0,l=t=>t),t.n!==a)return!1;const v=[];for(let e=1;e<=t.m;e++)v.push(n(c.row(t,e),u));return l(v)},c.scale=(t,e)=>c.map(t,(t=>t*e)),c.trans=t=>c(t.n,t.m,e((e=>c.col(t,e+1)),t.n).flat()),c.minor=(t,e,n)=>{if(t.m!==t.n)return!1;const r=[];for(let s=1;s<=t.m;s++)if(s!==e)for(let e=1;e<=t.n;e++)e!==n&&r.push(c.get(t,s,e));return c(t.m-1,t.n-1,r)},c.det=t=>{if(t.m!==t.n)return!1;if(1===t.m)return t.entries[0];if(2===t.m)return t.entries[0]*t.entries[3]-t.entries[1]*t.entries[2];let e=0,n=1;for(let r=1;r<=t.n;r++)e+=n*t.entries[r-1]*c.det(c.minor(t,1,r)),n*=-1;return e},c.nor=t=>{if(t.m!==t.n)return!1;const e=c.det(t);return c.map(t,(t=>t*e))},c.adj=t=>{const e=c(t.m,t.n);for(let n=1;n<=t.m;n++)for(let r=1;r<=t.n;r++)c.set(e,n,r,c.det(c.minor(t,n,r)));const n=c.map(e,((t,e)=>t*(e%2?-1:1)));return c.trans(n)},c.inv=t=>{if(t.m!==t.n)return!1;const e=c.det(t);return 0!==e&&c.scale(c.adj(t),1/e)},c.eq=(t,e)=>t.m===e.m&&t.n===e.n&&c.str(t)===c.str(e),c.cpy=t=>c(t.m,t.n,[...t.entries]),c.map=(t,e)=>c(t.m,t.n,t.entries.map(e)),c.str=(t,n=\", \",r=\"\\n\")=>((t,n)=>e((e=>t.slice(e*n,e*n+n)),Math.ceil(t.length/n)))(t.entries,t.n).map((t=>t.join(n))).join(r),t.exports={vec2:o,vec3:i,mat:c,isVec2:function(t){return t&&\"object\"==typeof t&&\"x\"in t&&\"number\"==typeof t.x&&\"y\"in t&&\"number\"==typeof t.y&&!(\"z\"in t)},isVec3:function(t){return t&&\"object\"==typeof t&&\"x\"in t&&\"number\"==typeof t.x&&\"y\"in t&&\"number\"==typeof t.y&&\"z\"in t&&\"number\"==typeof t.z},isMat:function(t){return t&&\"object\"==typeof t&&\"m\"in t&&\"number\"==typeof t.m&&\"n\"in t&&\"number\"==typeof t.n&&\"entries\"in t&&Array.isArray(t.entries)}}},513:t=>{function e(t,e,n){n=n||0;var r,s,o,i,c,a,u,l=[0,0];return r=t[1][1]-t[0][1],s=t[0][0]-t[1][0],o=r*t[0][0]+s*t[0][1],i=e[1][1]-e[0][1],c=e[0][0]-e[1][0],a=i*e[0][0]+c*e[0][1],z(u=r*c-i*s,0,n)||(l[0]=(c*o-s*a)/u,l[1]=(r*a-i*o)/u),l}function n(t,e,n,r){var s=e[0]-t[0],o=e[1]-t[1],i=r[0]-n[0],c=r[1]-n[1];if(i*o-c*s==0)return!1;var a=(s*(n[1]-t[1])+o*(t[0]-n[0]))/(i*o-c*s),u=(i*(t[1]-n[1])+c*(n[0]-t[0]))/(c*s-i*o);return a>=0&&a<=1&&u>=0&&u<=1}function r(t,e,n){return(e[0]-t[0])*(n[1]-t[1])-(n[0]-t[0])*(e[1]-t[1])}function s(t,e,n){return r(t,e,n)>0}function o(t,e,n){return r(t,e,n)>=0}function i(t,e,n){return r(t,e,n)<0}function c(t,e,n){return r(t,e,n)<=0}t.exports={decomp:function(t){var e=g(t);return e.length>0?M(t,e):[t]},quickDecomp:function t(e,n,r,a,u,l,m){l=l||100,m=m||0,u=u||25,n=void 0!==n?n:[],r=r||[],a=a||[];var p=[0,0],y=[0,0],b=[0,0],g=0,M=0,z=0,I=0,O=0,S=0,E=0,A=[],L=[],N=e,j=e;if(j.length<3)return n;if(++m>l)return console.warn(\"quickDecomp: max level (\"+l+\") reached.\"),n;for(var w=0;w<e.length;++w)if(h(N,w)){r.push(N[w]),g=M=Number.MAX_VALUE;for(var _=0;_<e.length;++_)s(f(N,w-1),f(N,w),f(N,_))&&c(f(N,w-1),f(N,w),f(N,_-1))&&(b=P(f(N,w-1),f(N,w),f(N,_),f(N,_-1)),i(f(N,w+1),f(N,w),b)&&(z=v(N[w],b))<M&&(M=z,y=b,S=_)),s(f(N,w+1),f(N,w),f(N,_+1))&&c(f(N,w+1),f(N,w),f(N,_))&&(b=P(f(N,w+1),f(N,w),f(N,_),f(N,_+1)),s(f(N,w-1),f(N,w),b)&&(z=v(N[w],b))<g&&(g=z,p=b,O=_));if(S===(O+1)%e.length)b[0]=(y[0]+p[0])/2,b[1]=(y[1]+p[1])/2,a.push(b),w<O?(d(A,N,w,O+1),A.push(b),L.push(b),0!==S&&d(L,N,S,N.length),d(L,N,0,w+1)):(0!==w&&d(A,N,w,N.length),d(A,N,0,O+1),A.push(b),L.push(b),d(L,N,S,w+1));else{if(S>O&&(O+=e.length),I=Number.MAX_VALUE,O<S)return n;for(_=S;_<=O;++_)o(f(N,w-1),f(N,w),f(N,_))&&c(f(N,w+1),f(N,w),f(N,_))&&(z=v(f(N,w),f(N,_)))<I&&x(N,w,_)&&(I=z,E=_%e.length);w<E?(d(A,N,w,E+1),0!==E&&d(L,N,E,j.length),d(L,N,0,w+1)):(0!==w&&d(A,N,w,j.length),d(A,N,0,E+1),d(L,N,E,w+1))}return A.length<L.length?(t(A,n,r,a,u,l,m),t(L,n,r,a,u,l,m)):(t(L,n,r,a,u,l,m),t(A,n,r,a,u,l,m)),n}return n.push(e),n},isSimple:function(t){var e,r=t;for(e=0;e<r.length-1;e++)for(var s=0;s<e-1;s++)if(n(r[e],r[e+1],r[s],r[s+1]))return!1;for(e=1;e<r.length-2;e++)if(n(r[0],r[r.length-1],r[e],r[e+1]))return!1;return!0},removeCollinearPoints:function(t,e){for(var n=0,r=t.length-1;t.length>3&&r>=0;--r)l(f(t,r-1),f(t,r),f(t,r+1),e)&&(t.splice(r%t.length,1),n++);return n},removeDuplicatePoints:function(t,e){for(var n=t.length-1;n>=1;--n)for(var r=t[n],s=n-1;s>=0;--s)I(r,t[s],e)&&t.splice(n,1)},makeCCW:function(t){for(var e=0,n=t,r=1;r<t.length;++r)(n[r][1]<n[e][1]||n[r][1]===n[e][1]&&n[r][0]>n[e][0])&&(e=r);return!s(f(t,e-1),f(t,e),f(t,e+1))&&(function(t){for(var e=[],n=t.length,r=0;r!==n;r++)e.push(t.pop());for(r=0;r!==n;r++)t[r]=e[r]}(t),!0)}};var a=[],u=[];function l(t,e,n,s){if(s){var o=a,i=u;o[0]=e[0]-t[0],o[1]=e[1]-t[1],i[0]=n[0]-e[0],i[1]=n[1]-e[1];var c=o[0]*i[0]+o[1]*i[1],l=Math.sqrt(o[0]*o[0]+o[1]*o[1]),v=Math.sqrt(i[0]*i[0]+i[1]*i[1]);return Math.acos(c/(l*v))<s}return 0===r(t,e,n)}function v(t,e){var n=e[0]-t[0],r=e[1]-t[1];return n*n+r*r}function f(t,e){var n=t.length;return t[e<0?e%n+n:e%n]}function d(t,e,n,r){for(var s=n;s<r;s++)t.push(e[s])}function h(t,e){return i(f(t,e-1),f(t,e),f(t,e+1))}var m=[],p=[];function y(t,n,r){var s,i,a=m,u=p;if(o(f(t,n+1),f(t,n),f(t,r))&&c(f(t,n-1),f(t,n),f(t,r)))return!1;i=v(f(t,n),f(t,r));for(var l=0;l!==t.length;++l)if((l+1)%t.length!==n&&l!==n&&o(f(t,n),f(t,r),f(t,l+1))&&c(f(t,n),f(t,r),f(t,l))&&(a[0]=f(t,n),a[1]=f(t,r),u[0]=f(t,l),u[1]=f(t,l+1),s=e(a,u),v(f(t,n),s)<i))return!1;return!0}function x(t,e,r){for(var s=0;s!==t.length;++s)if(s!==e&&s!==r&&(s+1)%t.length!==e&&(s+1)%t.length!==r&&n(f(t,e),f(t,r),f(t,s),f(t,s+1)))return!1;return!0}function b(t,e,n,r){var s=r||[];if(function(t){t.length=0}(s),e<n)for(var o=e;o<=n;o++)s.push(t[o]);else{for(o=0;o<=n;o++)s.push(t[o]);for(o=e;o<t.length;o++)s.push(t[o])}return s}function g(t){for(var e=[],n=[],r=[],s=[],o=Number.MAX_VALUE,i=0;i<t.length;++i)if(h(t,i))for(var c=0;c<t.length;++c)if(y(t,i,c)){n=g(b(t,i,c,s)),r=g(b(t,c,i,s));for(var a=0;a<r.length;a++)n.push(r[a]);n.length<o&&(e=n,o=n.length,e.push([f(t,i),f(t,c)]))}return e}function M(t,e){if(0===e.length)return[t];if(e instanceof Array&&e.length&&e[0]instanceof Array&&2===e[0].length&&e[0][0]instanceof Array){for(var n=[t],r=0;r<e.length;r++)for(var s=e[r],o=0;o<n.length;o++){var i=M(n[o],s);if(i){n.splice(o,1),n.push(i[0],i[1]);break}}return n}return s=e,r=t.indexOf(s[0]),o=t.indexOf(s[1]),-1!==r&&-1!==o&&[b(t,r,o),b(t,o,r)]}function P(t,e,n,r,s){s=s||0;var o=e[1]-t[1],i=t[0]-e[0],c=o*t[0]+i*t[1],a=r[1]-n[1],u=n[0]-r[0],l=a*n[0]+u*n[1],v=o*u-a*i;return z(v,0,s)?[0,0]:[(u*c-i*l)/v,(o*l-a*c)/v]}function z(t,e,n){return n=n||0,Math.abs(t-e)<=n}function I(t,e,n){return z(t[0],e[0],n)&&z(t[1],e[1],n)}},674:function(t,e,n){\"use strict\";var r,s=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var s=Object.getOwnPropertyDescriptor(e,n);s&&!(\"get\"in s?!e.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,s)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),o=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||(r=function(t){return r=Object.getOwnPropertyNames||function(t){var e=[];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[e.length]=n);return e},r(t)},function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n=r(t),i=0;i<n.length;i++)\"default\"!==n[i]&&s(e,t,n[i]);return o(e,t),e}),c=this&&this.__exportStar||function(t,e){for(var n in t)\"default\"===n||Object.prototype.hasOwnProperty.call(e,n)||s(e,t,n)};Object.defineProperty(e,\"__esModule\",{value:!0}),e.distance=function(t,e){return u.vec2.len(u.vec2.sub(t,e))},e.angle=function(t,e){if((0,v.vectorsAlmostEqual)(t,e))return 0;const n=u.vec2.rad(u.vec2.sub(e,t))%(2*Math.PI);return n<0?n+2*Math.PI:n},e.angleBetween=function(t,e){let n=(0,d.isRay)(t)?m(t,1):t,r=(0,d.isRay)(e)?m(e,1):e;if((0,v.vectorAlmostZero)(u.vec2.sub(n.end,n.start))||(0,v.vectorAlmostZero)(u.vec2.sub(r.end,r.start)))return 0;const s=u.vec2.nor(u.vec2.sub(n.end,n.start)),o=u.vec2.nor(u.vec2.sub(r.end,r.start)),i=(0,a.clamp)(u.vec2.dot(s,o),-1,1),c=u.vec2.cross(s,o),l=Math.atan2(c,i);return l<0?l+2*Math.PI:l},e.pointsAreCollinear=h,e.lineToRay=function(t){return{origin:t.start,direction:u.vec2.nor(u.vec2.sub(t.end,t.start))}},e.rayToLine=m,e.aabb=function(t){if((0,d.isLine)(t))return{position:(0,u.vec2)(Math.min(t.start.x,t.end.x),Math.min(t.start.y,t.end.y)),size:(0,u.vec2)(Math.abs(t.end.x-t.start.x),Math.abs(t.end.y-t.start.y))};if((0,d.isRectangle)(t)){const e=y(t),n=(0,u.vec2)(Math.min(...e.map((t=>t.x))),Math.min(...e.map((t=>t.y))));return{position:n,size:(0,u.vec2)(Math.max(...e.map((t=>t.x)))-n.x,Math.max(...e.map((t=>t.y)))-n.y)}}if((0,d.isCircle)(t))return{position:u.vec2.sub(t.position,(0,u.vec2)(t.radius,t.radius)),size:(0,u.vec2)(2*t.radius)};if((0,d.isPolygon)(t)){const e=(0,u.vec2)(Math.min(...t.vertices.map((t=>t.x))),Math.min(...t.vertices.map((t=>t.y))));return{position:e,size:(0,u.vec2)(Math.max(...t.vertices.map((t=>t.x)))-e.x,Math.max(...t.vertices.map((t=>t.y)))-e.y)}}return null},e.aabbToRectangle=function(t){return{position:u.vec2.add(t.position,u.vec2.div(t.size,2)),size:t.size,rotation:0}},e.aabbsOverlap=function(t,e){const n=(0,v.overlapInterval)({min:t.position.x,max:t.position.x+t.size.x},{min:e.position.x,max:e.position.x+e.size.x}),r=(0,v.overlapInterval)({min:t.position.y,max:t.position.y+t.size.y},{min:e.position.y,max:e.position.y+e.size.y});return n&&r?{intersects:!0,overlap:{position:(0,u.vec2)(n.min,r.min),size:(0,u.vec2)(n.max-n.min,r.max-r.min)}}:{intersects:!1}},e.pointInAABB=function(t,e){const{position:n,size:r}=e,s=n,o=u.vec2.add(n,r),i=(0,v.valueInInterval)(t.x,{min:s.x,max:o.x})&&(0,v.valueInInterval)(t.y,{min:s.y,max:o.y});let c,l;if(i){const e=[{x:s.x,y:t.y,d:Math.abs(t.x-s.x),normal:(0,u.vec2)(-1,0)},{x:o.x,y:t.y,d:Math.abs(t.x-o.x),normal:(0,u.vec2)(1,0)},{x:t.x,y:s.y,d:Math.abs(t.y-s.y),normal:(0,u.vec2)(0,-1)},{x:t.x,y:o.y,d:Math.abs(t.y-o.y),normal:(0,u.vec2)(0,1)}].reduce(((t,e)=>t.d<e.d?t:e));c=(0,u.vec2)(e.x,e.y),l=e.normal}else c=(0,u.vec2)((0,a.clamp)(t.x,s.x,o.x),(0,a.clamp)(t.y,s.y,o.y));const f=u.vec2.len(u.vec2.sub(t,c));return{intersects:i,closestPoint:c,distance:i?-f:f,normal:l}},e.encloseAABBs=function(...t){if(0===t.length)return{position:(0,u.vec2)(),size:(0,u.vec2)()};const e=Math.min(...t.map((({position:t})=>t.x))),n=Math.min(...t.map((({position:t})=>t.y))),r=Math.max(...t.map((({position:t,size:e})=>t.x+e.x))),s=Math.max(...t.map((({position:t,size:e})=>t.y+e.y)));return{position:(0,u.vec2)(e,n),size:(0,u.vec2)(r-e,s-n)}},e.rectangleIsRotated=p,e.rectangleVertices=y,e.verticesToEdges=x,e.polygonIsConvex=g,e.polygonSelfIntersects=M,e.polygonIsValid=P,e.polygonWindingOrder=z,e.polygonArea=function(t){if(!P(t))return null;let e=0;for(let n=0;n<t.vertices.length;n++){const r=t.vertices[n],s=(0,a.at)(t.vertices,n+1);e+=u.vec2.cross(r,s)}return Math.abs(e)/2},e.polygonCentroid=I,e.polygonConvexHull=function(t,e){var n;if(!P(t))return null;if(g(t))return t;const r=null===(n=null==e?void 0:e.keepWindingOrder)||void 0===n||n,s=z(t),o=[...t.vertices].sort(((t,e)=>t.x!==e.x?t.x-e.x:t.y-e.y)),i=[];for(const t of o){for(;i.length>=2&&u.vec2.cross(u.vec2.sub(i[i.length-1],i[i.length-2]),u.vec2.sub(t,i[i.length-1]))<=0;)i.pop();i.push(t)}const c=[];for(let t=o.length-1;t>=0;--t){const e=o[t];for(;c.length>=2&&u.vec2.cross(u.vec2.sub(c[c.length-1],c[c.length-2]),u.vec2.sub(e,c[c.length-1]))<=0;)c.pop();c.push(e)}i.pop(),c.pop();const a=i.concat(c);return a.length<3?null:(r&&z({vertices:a})!==s&&a.reverse(),{vertices:O(a)})},e.optimisePolygon=function(t){if(t.vertices.length<3)return null;const e=function(t){const e=[],n=t.length;for(let r=0;r<n;r++){const n=(0,a.at)(t,r-1),s=t[r];h(n,s,(0,a.at)(t,r+1))||e.push(s)}return e}(function(t){const e=[],n=t.length;for(let r=0;r<n;r++){const n=t[r],s=(0,a.at)(t,r+1);(0,v.vectorsAlmostEqual)(n,s)||e.push(n)}return e}(t.vertices));return e.length<3?null:{vertices:e}},e.decomposePolygon=S,e.pointOnRay=function(t,e){const n=u.vec2.sub(t,e.origin),r=u.vec2.nor(e.direction),s=u.vec2.dot(n,r),o=u.vec2.add(e.origin,u.vec2.mul(r,Math.max(0,s))),i=u.vec2.len(u.vec2.sub(t,o)),c=i<f.EPSILON&&s>=0;let a;if(!c){const t=u.vec2.rotf(r,-1),e=u.vec2.cross(r,n);a=u.vec2.mul(t,Math.sign(e))}return{intersects:c,closestPoint:o,distance:i,normal:a}},e.pointOnLine=E,e.pointInCircle=A,e.pointInRectangle=L,e.pointInPolygon=N,e.rayTraverseGrid=function(t,e,n,r,s=-1){if(e<=0)return{cells:[]};if((s=(0,a.clamp)(-1===s?1e4:s,0,1e4))<=0)return{cells:[]};n=u.vec2.map(n,Math.floor),r=u.vec2.map(r,Math.ceil);const o=u.vec2.nor(t.direction);if((0,v.vectorAlmostZero)(o))return{cells:[]};const i=[];let c=u.vec2.map(u.vec2.div(u.vec2.sub(t.origin,n),e),Math.floor);const l=u.vec2.sub(r,n);if(c.x<0||c.x>=l.x||c.y<0||c.y>=l.y){const s=w(t,{position:u.vec2.add(n,u.vec2.div(u.vec2.sub(r,n),2)),size:u.vec2.sub(r,n)});if(!s.intersects||!s.intersectionPoints)return{cells:i};const o=s.intersectionPoints[0];if(c=u.vec2.map(u.vec2.div(u.vec2.sub(o,n),e),Math.floor),c.x<0||c.x>=l.x||c.y<0||c.y>=l.y)return{cells:i}}const d=Math.sign(o.x),h=Math.sign(o.y),m={x:0!==o.x?Math.abs(e/o.x):1/0,y:0!==o.y?Math.abs(e/o.y):1/0},p=(0,u.vec2)(n.x+(c.x+(d>0?1:0))*e,n.y+(c.y+(h>0?1:0))*e),y={x:0!==o.x?Math.abs((p.x-t.origin.x)/o.x):1/0,y:0!==o.y?Math.abs((p.y-t.origin.y)/o.y):1/0};Math.abs(t.origin.x-p.x)<f.EPSILON&&(y.x=m.x),Math.abs(t.origin.y-p.y)<f.EPSILON&&(y.y=m.y),i.push((0,u.vec2)(c.x,c.y));let x=1;for(;x<s&&c.x>=0&&c.x<l.x&&c.y>=0&&c.y<l.y&&(y.x<y.y?(y.x+=m.x,c.x+=d):(y.y+=m.y,c.y+=h),!(c.x<0||c.x>=l.x||c.y<0||c.y>=l.y));)i.push((0,u.vec2)(c.x,c.y)),x++;return{cells:i}},e.rayIntersectsRay=function(t,e){const n=u.vec2.nor(t.direction),r=u.vec2.nor(e.direction);if((0,v.vectorAlmostZero)(n)||(0,v.vectorAlmostZero)(r))return{intersects:!1};const s=u.vec2.cross(n,r),o=u.vec2.sub(e.origin,t.origin);if(Math.abs(s)<f.EPSILON){if(Math.abs(u.vec2.cross(o,n))<f.EPSILON){const t=u.vec2.dot(o,n);if((t<=0||t>=0)&&u.vec2.dot(n,r)>1-f.EPSILON)return{intersects:!0}}return{intersects:!1}}const i=u.vec2.cross(o,r)/s,c=u.vec2.cross(o,n)/s;return i>=0&&c>=0?{intersects:!0,intersectionPoint:u.vec2.add(t.origin,u.vec2.mul(n,i))}:{intersects:!1}},e.rayIntersectsLine=j,e.rayIntersectsCircle=function(t,e){const n=u.vec2.nor(t.direction),r=u.vec2.sub(e.position,t.origin),s=u.vec2.dot(n,n),o=2*u.vec2.dot(n,u.vec2.mul(r,-1)),i=o*o-4*s*(u.vec2.dot(r,r)-e.radius*e.radius);if(i<-f.EPSILON)return{intersects:!1};if(Math.abs(i)<f.EPSILON){const e=-o/(2*s);return e>=0?{intersects:!0,intersectionPoints:[u.vec2.add(t.origin,u.vec2.mul(n,e))]}:{intersects:!1}}const c=Math.sqrt(i),a=(-o-c)/(2*s),l=(-o+c)/(2*s);if(l<0)return{intersects:!1};let v=[];return a>=0&&v.push(u.vec2.add(t.origin,u.vec2.mul(n,a))),l>=0&&v.push(u.vec2.add(t.origin,u.vec2.mul(n,l))),v=O(v),{intersects:v.length>0,intersectionPoints:v.length>0?v:void 0}},e.rayIntersectsRectangle=w,e.rayIntersectsPolygon=function(t,e){if(!P(e))return null;if(!g(e)){const n=S(e);return n?_(t,b(n)):null}return _(t,x(e.vertices))},e.lineIntersectsRay=function(t,e){return j(e,t)},e.lineIntersectsLine=k,e.lineIntersectsCircle=q,e.lineIntersectsRectangle=function(t,e){if((0,v.vectorAlmostZero)(e.size))return{intersects:!1};const n=y(e);if(L(t.start,e).intersects&&L(t.end,e).intersects)return{intersects:!0};let r=[];const s=x(n);for(const e of s){const n=k(t,e);n.intersects&&n.intersectionPoint&&r.push(n.intersectionPoint)}return r=O(r),r.length>1&&r.sort(((e,n)=>u.vec2.len(u.vec2.sub(e,t.start))-u.vec2.len(u.vec2.sub(n,t.start)))),{intersects:r.length>0,intersectionPoints:r.length>0?r:void 0}},e.lineIntersectsPolygon=function(t,e){if(!P(e))return null;if(!g(e)){const n=S(e);return n?C(t,e,b(n)):null}return C(t,e,x(e.vertices))},e.circleIntersectsCircle=function(t,e){const n=u.vec2.sub(e.position,t.position),r=u.vec2.len(n),s=t.radius+e.radius;if(r>s+f.EPSILON)return{intersects:!1};if(r<f.EPSILON&&Math.abs(t.radius-e.radius)<f.EPSILON)return{intersects:!0,minimumSeparation:u.vec2.mul(u.vec2.ux(),2*t.radius)};if(r<Math.abs(t.radius-e.radius)-f.EPSILON)return{intersects:!0,minimumSeparation:u.vec2.mul(u.vec2.nor(n),t.radius-r+e.radius)};const o=(t.radius*t.radius-e.radius*e.radius+r*r)/(2*r),i=Math.sqrt(Math.max(0,t.radius*t.radius-o*o)),c=u.vec2.add(t.position,u.vec2.mul(u.vec2.nor(n),o));if(Math.abs(r-s)<f.EPSILON)return{intersects:!0,intersectionPoints:[c],minimumSeparation:(0,u.vec2)()};const a=u.vec2.mul((0,u.vec2)({x:-n.y,y:n.x}),i/r);return{intersects:!0,intersectionPoints:[u.vec2.add(c,a),u.vec2.sub(c,a)],minimumSeparation:u.vec2.mul(u.vec2.nor(n),s-r)}},e.circleIntersectsRectangle=function(t,e){const n=x(y(e)),r=L(t.position,e),s=r.intersects,o=A(e.position,t).intersects,i=[];for(const e of n){const n=q(e,t);n.intersects&&n.intersectionPoints&&i.push(...n.intersectionPoints)}let c;if(c=Math.abs(r.distance)<f.EPSILON?(0,u.vec2)():r.distance<0?u.vec2.mul(u.vec2.nor(u.vec2.sub(r.closestPoint,t.position)),t.radius+Math.abs(r.distance)):u.vec2.mul(u.vec2.nor(u.vec2.sub(t.position,r.closestPoint)),t.radius-r.distance),(s||o)&&0===i.length)return{intersects:!0,minimumSeparation:c};const a=O(i);return a.length>0?{intersects:!0,intersectionPoints:a,minimumSeparation:c}:{intersects:!1}},e.circleIntersectsPolygon=function t(e,n,r){var s,o,i,c,a,l;if(!P(n))return null;const d=null!==(s=null==r?void 0:r.findMinimumSeparation)&&void 0!==s&&s,h=N(e.position,n),m=null!==(o=null==h?void 0:h.intersects)&&void 0!==o&&o;if(!g(n)){const s=S(n);if(!s)return null;const o=s.every((t=>{var n;const r=I(t);return!!r&&null!==(n=A(r,e).intersects)&&void 0!==n&&n})),l=b(s),h=R(e,l,m,o);if(h.intersects&&d){let o=0,l=null,d=(0,u.vec2)(),m=!0;for(;m&&(null===l||!(0,v.vectorsAlmostEqual)(l,d))&&++o<10;){let o=[],v=u.vec2.add(e.position,d);for(const t of s){const n=N(v,t);if(!n)continue;let r;r=Math.abs(n.distance)<f.EPSILON?(0,u.vec2)():n.distance<0?u.vec2.mul(u.vec2.nor(u.vec2.sub(n.closestPoint,v)),e.radius+Math.abs(n.distance)):u.vec2.mul(u.vec2.nor(u.vec2.sub(v,n.closestPoint)),e.radius-n.distance),o.push({separation:r,distance:Math.abs(n.distance)})}o=o.sort(((t,e)=>t.distance-e.distance)),l=u.vec2.cpy(d),d=u.vec2.add(d,(null===(i=o[0])||void 0===i?void 0:i.separation)||(0,u.vec2)()),m=null!==(a=null===(c=t({...e,position:u.vec2.add(e.position,u.vec2.mul(d,1.01))},n,{...r,findMinimumSeparation:!1}))||void 0===c?void 0:c.intersects)&&void 0!==a&&a}return{...h,minimumSeparation:d}}return h}const p=null!==(l=A(I(n),e).intersects)&&void 0!==l&&l,y=x(n.vertices),M=R(e,y,m,p);if(M.intersects&&d){let t;return t=Math.abs(h.distance)<f.EPSILON?(0,u.vec2)():h.distance<0?u.vec2.mul(u.vec2.nor(u.vec2.sub(h.closestPoint,e.position)),e.radius+Math.abs(h.distance)):u.vec2.mul(u.vec2.nor(u.vec2.sub(e.position,h.closestPoint)),e.radius-h.distance),{...M,minimumSeparation:t}}return M},e.rectangleIntersectsRectangle=function(t,e){if((0,v.vectorAlmostZero)(t.size)||(0,v.vectorAlmostZero)(e.size))return{intersects:!1};const n=y(t),r=y(e),s=x(n),o=x(r),i=[];for(const t of[...s,...o]){const e=u.vec2.sub(t.end,t.start),n=u.vec2.nor(u.vec2.rotf(e,-1));i.some((t=>Math.abs(u.vec2.dot(t,n))>1-f.EPSILON))||i.push(n)}let c=1/0,a=(0,u.vec2)();for(const t of i){const e=V(n,t),s=V(r,t);if(e.max<s.min||s.max<e.min)return{intersects:!1};const o=Math.min(e.max-s.min,s.max-e.min);o<c&&(c=o,a=t)}const l=[];for(const t of s)for(const e of o){const n=k(t,e);n.intersects&&n.intersectionPoint&&l.push(n.intersectionPoint)}const d=O(l),h=t.position,m=e.position,p=u.vec2.sub(m,h);u.vec2.dot(a,p)<0&&(a=u.vec2.mul(a,-1));const b=u.vec2.mul(a,c);return{intersects:!0,intersectionPoints:d.length>0?d:void 0,minimumSeparation:b}},e.rectangleIntersectsPolygon=function(t,e){if(!P(e))return null;if((0,v.vectorAlmostZero)(t.size))return{intersects:!1};return Z({vertices:y(t)},e)},e.polygonIntersectsPolygon=Z;const a=n(395),u=n(430),l=i(n(513)),v=n(955),f=i(n(388)),d=n(233);function h(t,e,n){const r=.5*Math.abs(t.x*(e.y-n.y)+e.x*(n.y-t.y)+n.x*(t.y-e.y));return Math.abs(r)<f.EPSILON}function m(t,e=1){return{start:t.origin,end:u.vec2.add(t.origin,u.vec2.mul(t.direction,e))}}function p(t){return void 0!==t.rotation&&Math.abs(t.rotation)>f.EPSILON}function y(t){const{position:e,size:n,rotation:r=0}=t,s=u.vec2.div(n,2);let o=u.vec2.fromComponents(u.vec2.swiz(s,\"XY\")),i=u.vec2.fromComponents(u.vec2.swiz(s,\"xY\")),c=u.vec2.fromComponents(u.vec2.swiz(s,\"xy\")),a=u.vec2.fromComponents(u.vec2.swiz(s,\"Xy\"));return p(t)&&(o=u.vec2.rot(o,r),i=u.vec2.rot(i,r),c=u.vec2.rot(c,r),a=u.vec2.rot(a,r)),[u.vec2.add(e,o),u.vec2.add(e,i),u.vec2.add(e,c),u.vec2.add(e,a)]}function x(t){const e=[];for(let n=0;n<t.length;n++){const r=t[n],s=(0,a.at)(t,n+1);e.push({start:r,end:s})}return e}function b(t){const e=t.flatMap((t=>x(t.vertices))),n=(t,e)=>{const n=k(t,e);return!(!n.intersects||n.intersectionPoint||(0,v.vectorsAlmostEqual)(t.end,e.start)&&!(0,v.vectorsAlmostEqual)(t.start,e.end)||(0,v.vectorsAlmostEqual)(t.start,e.end)&&!(0,v.vectorsAlmostEqual)(t.end,e.start))},r=[];for(const t of e)r.some((e=>n(e,t)))||e.some((e=>e!==t&&n(e,t)))||r.push(t);return r}function g(t){if(!P(t))return null;let e=0;for(let n=0;n<t.vertices.length;n++){const r=t.vertices[n],s=(0,a.at)(t.vertices,n+1),o=(0,a.at)(t.vertices,n+2),i=(s.x-r.x)*(o.y-r.y)-(s.y-r.y)*(o.x-r.x);if(0!==i)if(0===e)e=Math.sign(i);else if(Math.sign(i)!==e)return!1}return!0}function M(t){if(t.vertices.length<3)return!1;const e=t.vertices.length;for(let n=0;n<e;n++){const r=t.vertices[n],s=(0,a.at)(t.vertices,n+1);for(let o=n+2;o<e;o++){const i=t.vertices[o],c=(0,a.at)(t.vertices,o+1);if(0===n&&o===e-1)continue;const{intersects:u}=k({start:r,end:s},{start:i,end:c});if(u)return!0}}return!1}function P(t){return t.vertices.length>=3&&!M(t)}function z(t,e){if(!P(t))return null;let n=0;for(let e=0;e<t.vertices.length;e++){const r=t.vertices[e],s=(0,a.at)(t.vertices,e+1);n+=(s.x-r.x)*(s.y+r.y)}switch((null==e?void 0:e.coordinateSystem)||\"screen\"){case\"cartesian\":return n>0?\"clockwise\":\"counter-clockwise\";case\"screen\":return n>0?\"counter-clockwise\":\"clockwise\";default:return null}}function I(t){return P(t)?t.vertices.every(((t,e,n)=>h(t,(0,a.at)(n,e+1),(0,a.at)(n,e+2))))?null:u.vec2.div([...t.vertices].reduce(((t,e)=>u.vec2.add(t,e)),(0,u.vec2)()),t.vertices.length):null}function O(t){const e=[],n=t.length;for(let r=0;r<n;r++){const n=t[r];e.some((t=>(0,v.vectorsAlmostEqual)(n,t)))||e.push(n)}return e}function S(t,e){var n;if(!P(t))return null;if(g(t))return[t];const r=(null==e?void 0:e.mode)||\"fast\",s=null===(n=null==e?void 0:e.keepWindingOrder)||void 0===n||n,o=z(t),i=t.vertices.map((t=>[t.x,t.y]));\"counter-clockwise\"===o&&i.reverse();let c=[];switch(r){case\"fast\":c=l.quickDecomp(i);break;case\"optimal\":c=l.decomp(i)}const a=[];for(const t of c)a.push({vertices:t.map((t=>(0,u.vec2)(t[0],t[1])))});if(s)for(const t of a)z(t)!==o&&t.vertices.reverse();return a.length>0?a:null}function E(t,e){const n=u.vec2.sub(e.end,e.start),r=u.vec2.nor(n),s=u.vec2.sub(t,e.start),o=u.vec2.dot(s,r),i=u.vec2.len(n),c=Math.max(0,Math.min(i,o)),a=u.vec2.add(e.start,u.vec2.mul(r,c)),l=u.vec2.len(u.vec2.sub(t,a)),v=l<f.EPSILON;let d;if(!v){const t=u.vec2.rotf(r,-1),e=u.vec2.cross(r,s);d=u.vec2.mul(t,Math.sign(e))}return{intersects:v,closestPoint:a,distance:l,normal:d}}function A(t,e){const n=u.vec2.sub(t,e.position),r=u.vec2.len(n),s=r<=e.radius,o=s?-(e.radius-r):r-e.radius;return{intersects:s,closestPoint:u.vec2.add(e.position,u.vec2.mul(u.vec2.nor(n),e.radius)),distance:o,normal:s?u.vec2.nor(n):void 0}}function L(t,e){if((0,v.vectorAlmostZero)(e.size)){const n=(0,v.vectorsAlmostEqual)(t,e.position);return{intersects:n,closestPoint:e.position,distance:n?0:u.vec2.len(u.vec2.sub(t,e.position))}}const n=N(t,{vertices:y(e)});if(!n)throw new Error(\"Invalid rectangle vertices\");return n}function N(t,e){if(!P(e))return null;const n=z(e);let r=!1;const s=e.vertices;let o,i=1/0,c=t;for(let e=0;e<s.length;e++){const a=(e+1)%s.length,l=s[e],v=s[a];l.y>t.y!=v.y>t.y&&t.x<(v.x-l.x)*(t.y-l.y)/(v.y-l.y)+l.x&&(r=!r);const f={start:l,end:v},{closestPoint:d,distance:h}=E(t,f),m=h*h;m<i&&(i=m,c=d,o=u.vec2.rotf(u.vec2.nor(u.vec2.sub(v,l)),\"clockwise\"===n?1:-1))}const a=Math.sqrt(i);return{intersects:r,closestPoint:c,distance:r?-a:a,normal:r?o:void 0}}function j(t,e){const n=u.vec2.sub(e.end,e.start),r=u.vec2.nor(t.direction);if((0,v.vectorAlmostZero)(n)||(0,v.vectorAlmostZero)(r))return{intersects:!1};const s=u.vec2.cross(r,n),o=u.vec2.sub(e.start,t.origin);if(Math.abs(s)<f.EPSILON){if(Math.abs(u.vec2.cross(o,r))<f.EPSILON){const s=u.vec2.dot(u.vec2.sub(e.start,t.origin),r),o=u.vec2.dot(u.vec2.sub(e.end,t.origin),r);if((s>=0||o>=0)&&Math.min(s,o)<=u.vec2.len(n))return{intersects:!0}}return{intersects:!1}}const i=u.vec2.cross(o,n)/s,c=u.vec2.cross(o,r)/s;return i>=0&&c>=0&&c<=1?{intersects:!0,intersectionPoint:u.vec2.add(t.origin,u.vec2.mul(r,i))}:{intersects:!1}}function w(t,e){let n=[];const r=x(y(e));for(const e of r){const r=j(t,e);r.intersects&&r.intersectionPoint&&n.push(r.intersectionPoint)}if(n=O(n),n.length>1){const e=u.vec2.nor(t.direction);n.sort(((n,r)=>u.vec2.dot(u.vec2.sub(n,t.origin),e)-u.vec2.dot(u.vec2.sub(r,t.origin),e)))}return{intersects:n.length>0,intersectionPoints:n.length>0?n:void 0}}function _(t,e){let n=[];for(const r of e){const e=j(t,r);e.intersects&&e.intersectionPoint&&n.push(e.intersectionPoint)}if(n=O(n),n.length>1){const e=u.vec2.nor(t.direction);n.sort(((n,r)=>u.vec2.dot(u.vec2.sub(n,t.origin),e)-u.vec2.dot(u.vec2.sub(r,t.origin),e)))}return{intersects:n.length>0,intersectionPoints:n.length>0?n:void 0}}function k(t,e){const n=u.vec2.sub(t.end,t.start),r=u.vec2.sub(e.end,e.start);if((0,v.vectorAlmostZero)(n)||(0,v.vectorAlmostZero)(r))return{intersects:!1};const s=u.vec2.cross(n,r),o=u.vec2.sub(e.start,t.start);if(Math.abs(s)<f.EPSILON){if(Math.abs(u.vec2.cross(o,n))<f.EPSILON){const t=u.vec2.dot(o,n)/u.vec2.dot(n,n),e=t+u.vec2.dot(r,n)/u.vec2.dot(n,n),s=Math.min(t,e),i=Math.max(t,e);if(s<=1&&i>=0)return{intersects:!0}}return{intersects:!1}}const i=u.vec2.cross(o,r)/s,c=u.vec2.cross(o,n)/s;return i>=0&&i<=1&&c>=0&&c<=1?{intersects:!0,intersectionPoint:u.vec2.add(t.start,u.vec2.mul(n,i))}:{intersects:!1}}function q(t,e){const n=u.vec2.sub(t.end,t.start),r=u.vec2.dot(n,n);if(r<f.EPSILON)return{intersects:!1};if(A(t.start,e).intersects&&A(t.end,e).intersects)return{intersects:!0};const s=u.vec2.sub(e.position,t.start),o=r,i=2*u.vec2.dot(n,u.vec2.mul(s,-1)),c=i*i-4*o*(u.vec2.dot(s,s)-e.radius*e.radius);if(c<-f.EPSILON)return{intersects:!1};if(Math.abs(c)<f.EPSILON){const e=-i/(2*o);return e>=0&&e<=1?{intersects:!0,intersectionPoints:[u.vec2.add(t.start,u.vec2.mul(n,e))]}:{intersects:!1}}const a=Math.sqrt(c),l=(-i-a)/(2*o),v=(-i+a)/(2*o);let d=[];return v<0||l>1?{intersects:!1}:(l>=0&&l<=1&&d.push(u.vec2.add(t.start,u.vec2.mul(n,l))),v>=0&&v<=1&&d.push(u.vec2.add(t.start,u.vec2.mul(n,v))),d=O(d),d.length>1&&d.sort(((e,n)=>u.vec2.len(u.vec2.sub(e,t.start))-u.vec2.len(u.vec2.sub(n,t.start)))),{intersects:d.length>0,intersectionPoints:d.length>0?d:void 0})}function C(t,e,n){const r=N({x:(t.start.x+t.end.x)/2,y:(t.start.y+t.end.y)/2},e),s=N(t.start,e),o=N(t.end,e);if((null==r?void 0:r.intersects)&&(null==s?void 0:s.intersects)&&(null==o?void 0:o.intersects))return{intersects:!0};let i=[];for(const e of n){const n=k(t,e);n.intersects&&n.intersectionPoint&&i.push(n.intersectionPoint)}return i=O(i),i.length>1&&i.sort(((e,n)=>u.vec2.len(u.vec2.sub(e,t.start))-u.vec2.len(u.vec2.sub(n,t.start)))),{intersects:i.length>0,intersectionPoints:i.length>0?i:void 0}}function R(t,e,n,r){let s=[];for(const n of e){const e=q(n,t);e.intersects&&e.intersectionPoints&&s.push(...e.intersectionPoints)}return(n||r)&&0===s.length?{intersects:!0}:(s=O(s),{intersects:s.length>0,intersectionPoints:s.length>0?s:void 0})}function V(t,e){let n=1/0,r=-1/0;for(const s of t){const t=u.vec2.dot(s,e);n=Math.min(n,t),r=Math.max(r,t)}return{min:n,max:r}}function Z(t,e){if(!P(t)||!P(e))return null;let n=[];if(g(t))n=[t];else{const e=S(t);if(!e)return null;n=e}let r=[];if(g(e))r=[e];else{const t=S(e);if(!t)return null;r=t}const s=b(n),o=b(r),i=[];for(const t of s)for(const e of o){const n=k(t,e);n.intersects&&n.intersectionPoint&&i.push(n.intersectionPoint)}if(0===i.length){if(n.map(I).filter((t=>!!t)).every((t=>{var n;return null===(n=N(t,e))||void 0===n?void 0:n.intersects})))return{intersects:!0};if(r.map(I).filter((t=>!!t)).every((e=>{var n;return null===(n=N(e,t))||void 0===n?void 0:n.intersects})))return{intersects:!0}}const c=O(i);return{intersects:c.length>0,intersectionPoints:c.length>0?c:void 0}}c(n(233),e)},233:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.isPoint=s,e.isRay=function(t){return t&&\"object\"==typeof t&&\"origin\"in t&&s(t.origin)&&\"direction\"in t&&(0,r.isVec2)(t.direction)},e.isLine=function(t){return t&&\"object\"==typeof t&&\"start\"in t&&s(t.start)&&\"end\"in t&&s(t.end)},e.isCircle=function(t){return t&&\"object\"==typeof t&&\"position\"in t&&s(t.position)&&\"radius\"in t&&\"number\"==typeof t.radius},e.isAABB=function(t){return t&&\"object\"==typeof t&&\"position\"in t&&s(t.position)&&\"size\"in t&&(0,r.isVec2)(t.size)},e.isRectangle=function(t){return t&&\"object\"==typeof t&&\"position\"in t&&s(t.position)&&\"size\"in t&&(0,r.isVec2)(t.size)&&(!(\"rotation\"in t)||\"number\"==typeof t.rotation)},e.isPolygon=function(t){return t&&\"object\"==typeof t&&\"vertices\"in t&&Array.isArray(t.vertices)&&t.vertices.every(s)};const r=n(430);function s(t){return(0,r.isVec2)(t)}},388:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.EPSILON=void 0,e.EPSILON=1e-6},955:function(t,e,n){\"use strict\";var r,s=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var s=Object.getOwnPropertyDescriptor(e,n);s&&!(\"get\"in s?!e.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,s)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),o=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||(r=function(t){return r=Object.getOwnPropertyNames||function(t){var e=[];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[e.length]=n);return e},r(t)},function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n=r(t),i=0;i<n.length;i++)\"default\"!==n[i]&&s(e,t,n[i]);return o(e,t),e}),c=this&&this.__exportStar||function(t,e){for(var n in t)\"default\"===n||Object.prototype.hasOwnProperty.call(e,n)||s(e,t,n)};Object.defineProperty(e,\"__esModule\",{value:!0}),e.vectorAlmostZero=function(t){return(0,a.isVec3)(t)?Math.abs(t.x)<u.EPSILON&&Math.abs(t.y)<u.EPSILON&&Math.abs(t.z)<u.EPSILON:!!(0,a.isVec2)(t)&&Math.abs(t.x)<u.EPSILON&&Math.abs(t.y)<u.EPSILON},e.vectorsAlmostEqual=function(t,e){return(0,a.isVec3)(t)&&(0,a.isVec3)(e)?Math.abs(t.x-e.x)<u.EPSILON&&Math.abs(t.y-e.y)<u.EPSILON&&Math.abs(t.z-e.z)<u.EPSILON:!(!(0,a.isVec2)(t)||!(0,a.isVec2)(e))&&Math.abs(t.x-e.x)<u.EPSILON&&Math.abs(t.y-e.y)<u.EPSILON},e.valueInInterval=function(t,e){const{min:n,minInclusive:r=!0,max:s,maxInclusive:o=!0}=e;return(r?t>=n:t>n)&&(o?t<=s:t<s)},e.intervalsOverlap=l,e.overlapInterval=function(t,e){return l(t,e)?{min:Math.max(t.min,e.min),max:Math.min(t.max,e.max)}:null};const a=n(430),u=i(n(388));function l(t,e){return Math.max(t.min,e.min)<=Math.min(t.max,e.max)}c(n(197),e)},197:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0})}},e={},function n(r){var s=e[r];if(void 0!==s)return s.exports;var o=e[r]={exports:{}};return t[r].call(o.exports,o,o.exports,n),o.exports}(674);var t,e}));\n\n//# sourceURL=webpack://@basementuniverse/particles-2d/./node_modules/@basementuniverse/intersection-helpers/build/2d/index.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js ***!
  \**************************************************************************************/
/***/ (function(module) {

eval("!function(e,t){if(true)module.exports=t();else { var n, r; }}(this,(()=>{return e={430:e=>{const t=(e,t)=>Array(t).fill(0).map(((t,r)=>e(r))),r=(e,t)=>e.reduce(((e,r,n)=>e+r*t[n]),0),n=e=>\"object\"==typeof e&&\"x\"in e&&\"y\"in e,a=e=>\"object\"==typeof e&&\"x\"in e&&\"y\"in e&&\"z\"in e,s=(e,t)=>e||t?n(e)?{x:e.x||0,y:e.y||0}:{x:e,y:t??e}:{x:0,y:0};s.components=e=>[e.x,e.y],s.fromComponents=e=>s(...e.slice(0,2)),s.ux=()=>s(1,0),s.uy=()=>s(0,1),s.add=(e,t)=>({x:e.x+(t.x??t),y:e.y+(t.y??t)}),s.addm=(...e)=>e.reduce(((e,t)=>s.add(e,t)),s()),s.sub=(e,t)=>({x:e.x-(t.x??t),y:e.y-(t.y??t)}),s.subm=(...e)=>e.reduce(((e,t)=>s.sub(e,t))),s.mul=(e,t)=>({x:e.x*(t.x??t),y:e.y*(t.y??t)}),s.scale=(e,t)=>s.mul(e,t),s.div=(e,t)=>({x:e.x/(t.x??t),y:e.y/(t.y??t)}),s.len=e=>Math.sqrt(e.x*e.x+e.y*e.y),s.manhattan=e=>Math.abs(e.x)+Math.abs(e.y),s.nor=e=>{let t=s.len(e);return t?{x:e.x/t,y:e.y/t}:s()},s.dot=(e,t)=>e.x*t.x+e.y*t.y,s.rot=(e,t)=>{let r=Math.sin(t),n=Math.cos(t);return{x:n*e.x-r*e.y,y:r*e.x+n*e.y}},s.rotf=(e,t)=>{switch(t){case 1:return s(e.y,-e.x);case-1:return s(-e.y,e.x);case 2:case-2:return s(-e.x,-e.y);default:return e}},s.cross=(e,t)=>e.x*t.y-e.y*t.x,s.eq=(e,t)=>e.x===t.x&&e.y===t.y,s.rad=e=>Math.atan2(e.y,e.x),s.cpy=e=>s(e),s.map=(e,t)=>({x:t(e.x,\"x\"),y:t(e.y,\"y\")}),s.str=(e,t=\", \")=>`${e.x}${t}${e.y}`,s.swiz=(e,t=\"..\")=>{const r=[];return t.split(\"\").forEach(((t,n)=>{switch(t){case\"x\":case\"u\":r.push(e.x);break;case\"y\":case\"v\":r.push(e.y);break;case\"X\":case\"U\":r.push(-e.x);break;case\"Y\":case\"V\":r.push(-e.y);break;case\"0\":default:r.push(0);break;case\"1\":r.push(1);break;case\".\":r.push([e.x,e.y][n]??0)}})),r},s.polar=e=>({r:s.len(e),theta:Math.atan2(e.y,e.x)}),s.fromPolar=(e,t)=>s(e*Math.cos(t),e*Math.sin(t));const o=(e,t,r)=>e||t||r?a(e)?{x:e.x||0,y:e.y||0,z:e.z||0}:n(e)?{x:e.x||0,y:e.y||0,z:t||0}:{x:e,y:t??e,z:r??e}:{x:0,y:0,z:0};o.components=e=>[e.x,e.y,e.z],o.fromComponents=e=>o(...e.slice(0,3)),o.ux=()=>o(1,0,0),o.uy=()=>o(0,1,0),o.uz=()=>o(0,0,1),o.add=(e,t)=>({x:e.x+(t.x??t),y:e.y+(t.y??t),z:e.z+(t.z??t)}),o.addm=(...e)=>e.reduce(((e,t)=>o.add(e,t)),o()),o.sub=(e,t)=>({x:e.x-(t.x??t),y:e.y-(t.y??t),z:e.z-(t.z??t)}),o.subm=(...e)=>e.reduce(((e,t)=>o.sub(e,t))),o.mul=(e,t)=>({x:e.x*(t.x??t),y:e.y*(t.y??t),z:e.z*(t.z??t)}),o.scale=(e,t)=>o.mul(e,t),o.div=(e,t)=>({x:e.x/(t.x??t),y:e.y/(t.y??t),z:e.z/(t.z??t)}),o.len=e=>Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z),o.manhattan=e=>Math.abs(e.x)+Math.abs(e.y)+Math.abs(e.z),o.nor=e=>{let t=o.len(e);return t?{x:e.x/t,y:e.y/t,z:e.z/t}:o()},o.dot=(e,t)=>e.x*t.x+e.y*t.y+e.z*t.z,o.rot=(e,t)=>o(o.dot(o.fromComponents(c.row(t,1)),e),o.dot(o.fromComponents(c.row(t,2)),e),o.dot(o.fromComponents(c.row(t,3)),e)),o.rotx=(e,t)=>o(e.x,e.y*Math.cos(t)-e.z*Math.sin(t),e.y*Math.sin(t)+e.z*Math.cos(t)),o.roty=(e,t)=>o(e.x*Math.cos(t)+e.z*Math.sin(t),e.y,-e.x*Math.sin(t)+e.z*Math.cos(t)),o.rotz=(e,t)=>o(e.x*Math.cos(t)-e.y*Math.sin(t),e.x*Math.sin(t)+e.y*Math.cos(t),e.z),o.rotq=(e,t)=>{if(4!==t.length)return o();const r=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]+t[3]*t[3]);if(0===r)return o();const n=[t[0]/r,t[1]/r,t[2]/r,t[3]/r],a=o(...n.slice(0,3)),s=n[3];return o.add(o.add(o.mul(a,2*o.dot(a,e)),o.mul(e,s*s-o.dot(a,a))),o.mul(o.cross(a,e),2*s))},o.rota=(e,t)=>o.rotz(o.roty(o.rotx(e,t.x),t.y),t.z),o.cross=(e,t)=>o(e.y*t.z-e.z*t.y,e.z*t.x-e.x*t.z,e.x*t.y-e.y*t.x),o.eq=(e,t)=>e.x===t.x&&e.y===t.y&&e.z===t.z,o.radx=e=>Math.atan2(e.z,e.y),o.rady=e=>Math.atan2(e.x,e.y),o.radz=e=>Math.atan2(e.y,e.z),o.cpy=e=>o(e),o.map=(e,t)=>({x:t(e.x,\"x\"),y:t(e.y,\"y\"),z:t(e.z,\"z\")}),o.str=(e,t=\", \")=>`${e.x}${t}${e.y}${t}${e.z}`,o.swiz=(e,t=\"...\")=>{const r=[];return t.split(\"\").forEach(((t,n)=>{switch(t){case\"x\":case\"u\":case\"r\":r.push(e.x);break;case\"y\":case\"v\":case\"g\":r.push(e.y);break;case\"z\":case\"w\":case\"b\":r.push(e.z);break;case\"X\":case\"U\":case\"R\":r.push(-e.x);break;case\"Y\":case\"V\":case\"G\":r.push(-e.y);break;case\"Z\":case\"W\":case\"B\":r.push(-e.z);break;case\"0\":default:r.push(0);break;case\"1\":r.push(1);break;case\".\":r.push([e.x,e.y,e.z][n]??0)}})),r},o.polar=e=>{let t=o.len(e);return{r:t,theta:Math.acos(e.y/t),phi:Math.atan2(e.z,e.x)}},o.fromPolar=(e,t,r)=>{const n=Math.sin(t);return o(e*n*Math.cos(r),e*Math.cos(t),e*n*Math.sin(r))};const c=(e=4,t=4,r=[])=>({m:e,n:t,entries:r.concat(Array(e*t).fill(0)).slice(0,e*t)});c.identity=e=>c(e,e,Array(e*e).fill(0).map(((t,r)=>+(Math.floor(r/e)===r%e)))),c.get=(e,t,r)=>e.entries[r-1+(t-1)*e.n],c.set=(e,t,r,n)=>{e.entries[r-1+(t-1)*e.n]=n},c.row=(e,t)=>{const r=(t-1)*e.n;return e.entries.slice(r,r+e.n)},c.col=(e,r)=>t((t=>c.get(e,t+1,r)),e.m),c.add=(e,t)=>e.m===t.m&&e.n===t.n&&c.map(e,((e,r)=>e+t.entries[r])),c.sub=(e,t)=>e.m===t.m&&e.n===t.n&&c.map(e,((e,r)=>e-t.entries[r])),c.mul=(e,t)=>{if(e.n!==t.m)return!1;const n=c(e.m,t.n);for(let a=1;a<=e.m;a++)for(let s=1;s<=t.n;s++)c.set(n,a,s,r(c.row(e,a),c.col(t,s)));return n},c.mulv=(e,t)=>{let i,u,y;if(a(t)?(u=o.components(t),i=3,y=o.fromComponents):n(t)?(u=s.components(t),i=2,y=s.fromComponents):(u=t,i=t.length??0,y=e=>e),e.n!==i)return!1;const x=[];for(let t=1;t<=e.m;t++)x.push(r(c.row(e,t),u));return y(x)},c.scale=(e,t)=>c.map(e,(e=>e*t)),c.trans=e=>c(e.n,e.m,t((t=>c.col(e,t+1)),e.n).flat()),c.minor=(e,t,r)=>{if(e.m!==e.n)return!1;const n=[];for(let a=1;a<=e.m;a++)if(a!==t)for(let t=1;t<=e.n;t++)t!==r&&n.push(c.get(e,a,t));return c(e.m-1,e.n-1,n)},c.det=e=>{if(e.m!==e.n)return!1;if(1===e.m)return e.entries[0];if(2===e.m)return e.entries[0]*e.entries[3]-e.entries[1]*e.entries[2];let t=0,r=1;for(let n=1;n<=e.n;n++)t+=r*e.entries[n-1]*c.det(c.minor(e,1,n)),r*=-1;return t},c.nor=e=>{if(e.m!==e.n)return!1;const t=c.det(e);return c.map(e,(e=>e*t))},c.adj=e=>{const t=c(e.m,e.n);for(let r=1;r<=e.m;r++)for(let n=1;n<=e.n;n++)c.set(t,r,n,c.det(c.minor(e,r,n)));const r=c.map(t,((e,t)=>e*(t%2?-1:1)));return c.trans(r)},c.inv=e=>{if(e.m!==e.n)return!1;const t=c.det(e);return 0!==t&&c.scale(c.adj(e),1/t)},c.eq=(e,t)=>e.m===t.m&&e.n===t.n&&c.str(e)===c.str(t),c.cpy=e=>c(e.m,e.n,[...e.entries]),c.map=(e,t)=>c(e.m,e.n,e.entries.map(t)),c.str=(e,r=\", \",n=\"\\n\")=>((e,r)=>t((t=>e.slice(t*r,t*r+r)),Math.ceil(e.length/r)))(e.entries,e.n).map((e=>e.join(r))).join(n),e.exports={vec2:s,vec3:o,mat:c,isVec2:function(e){return e&&\"object\"==typeof e&&\"x\"in e&&\"number\"==typeof e.x&&\"y\"in e&&\"number\"==typeof e.y&&!(\"z\"in e)},isVec3:function(e){return e&&\"object\"==typeof e&&\"x\"in e&&\"number\"==typeof e.x&&\"y\"in e&&\"number\"==typeof e.y&&\"z\"in e&&\"number\"==typeof e.z},isMat:function(e){return e&&\"object\"==typeof e&&\"m\"in e&&\"number\"==typeof e.m&&\"n\"in e&&\"number\"==typeof e.n&&\"entries\"in e&&Array.isArray(e.entries)}}},388:(e,t)=>{\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.EPSILON=void 0,t.EPSILON=1e-6},955:function(e,t,r){\"use strict\";var n,a=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!(\"get\"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,\"default\",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||(n=function(e){return n=Object.getOwnPropertyNames||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[t.length]=r);return t},n(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r=n(e),o=0;o<r.length;o++)\"default\"!==r[o]&&a(t,e,r[o]);return s(t,e),t}),c=this&&this.__exportStar||function(e,t){for(var r in e)\"default\"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,\"__esModule\",{value:!0}),t.vectorAlmostZero=function(e){return(0,i.isVec3)(e)?Math.abs(e.x)<u.EPSILON&&Math.abs(e.y)<u.EPSILON&&Math.abs(e.z)<u.EPSILON:!!(0,i.isVec2)(e)&&Math.abs(e.x)<u.EPSILON&&Math.abs(e.y)<u.EPSILON},t.vectorsAlmostEqual=function(e,t){return(0,i.isVec3)(e)&&(0,i.isVec3)(t)?Math.abs(e.x-t.x)<u.EPSILON&&Math.abs(e.y-t.y)<u.EPSILON&&Math.abs(e.z-t.z)<u.EPSILON:!(!(0,i.isVec2)(e)||!(0,i.isVec2)(t))&&Math.abs(e.x-t.x)<u.EPSILON&&Math.abs(e.y-t.y)<u.EPSILON},t.valueInInterval=function(e,t){const{min:r,minInclusive:n=!0,max:a,maxInclusive:s=!0}=t;return(n?e>=r:e>r)&&(s?e<=a:e<a)},t.intervalsOverlap=y,t.overlapInterval=function(e,t){return y(e,t)?{min:Math.max(e.min,t.min),max:Math.min(e.max,t.max)}:null};const i=r(430),u=o(r(388));function y(e,t){return Math.max(e.min,t.min)<=Math.min(e.max,t.max)}c(r(197),t)},197:(e,t)=>{\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0})}},t={},function r(n){var a=t[n];if(void 0!==a)return a.exports;var s=t[n]={exports:{}};return e[n].call(s.exports,s,s.exports,r),s.exports}(955);var e,t}));\n\n//# sourceURL=webpack://@basementuniverse/particles-2d/./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/parsecolor/parsecolor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@basementuniverse/parsecolor/parsecolor.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("/*\r\n\r\nParse a valid CSS color string into an object like: { r, g, b, a }\r\nProperties will have the correct interval and precision.\r\nValid input examples:\r\n\r\nred\r\n#f00\r\n#ff0000\r\n#ff0000ff\r\nrgb(255, 0, 0)\r\nrgb(100%, 0%, 0%)\r\nrgba(255, 0, 0, 1)\r\nrgba(100%, 0%, 0%, 1)\r\nhsl(0, 100%, 50%)\r\nhsla(0, 100%, 50%, 1)\r\n\r\n*/\r\nconst parseColor = (function() {\r\n\tconst names = {\r\n\t\t\"aliceblue\": \"f0f8ff\",\r\n\t\t\"antiquewhite\": \"faebd7\",\r\n\t\t\"aqua\": \"0ff\",\r\n\t\t\"aquamarine\": \"7fffd4\",\r\n\t\t\"azure\": \"f0ffff\",\r\n\t\t\"beige\": \"f5f5dc\",\r\n\t\t\"bisque\": \"ffe4c4\",\r\n\t\t\"black\": \"000\",\r\n\t\t\"blanchedalmond\": \"ffebcd\",\r\n\t\t\"blue\": \"00f\",\r\n\t\t\"blueviolet\": \"8a2be2\",\r\n\t\t\"brown\": \"a52a2a\",\r\n\t\t\"burlywood\": \"deb887\",\r\n\t\t\"cadetblue\": \"5f9ea0\",\r\n\t\t\"chartreuse\": \"7fff00\",\r\n\t\t\"chocolate\": \"d2691e\",\r\n\t\t\"coral\": \"ff7f50\",\r\n\t\t\"cornflowerblue\": \"6495ed\",\r\n\t\t\"cornsilk\": \"fff8dc\",\r\n\t\t\"crimson\": \"dc143c\",\r\n\t\t\"cyan\": \"0ff\",\r\n\t\t\"darkblue\": \"00008b\",\r\n\t\t\"darkcyan\": \"008b8b\",\r\n\t\t\"darkgoldenrod\": \"b8860b\",\r\n\t\t\"darkgray\": \"a9a9a9\",\r\n\t\t\"darkgreen\": \"006400\",\r\n\t\t\"darkgrey\": \"a9a9a9\",\r\n\t\t\"darkkhaki\": \"bdb76b\",\r\n\t\t\"darkmagenta\": \"8b008b\",\r\n\t\t\"darkolivegreen\": \"556b2f\",\r\n\t\t\"darkorange\": \"ff8c00\",\r\n\t\t\"darkorchid\": \"9932cc\",\r\n\t\t\"darkred\": \"8b0000\",\r\n\t\t\"darksalmon\": \"e9967a\",\r\n\t\t\"darkseagreen\": \"8fbc8f\",\r\n\t\t\"darkslateblue\": \"483d8b\",\r\n\t\t\"darkslategray\": \"2f4f4f\",\r\n\t\t\"darkslategrey\": \"2f4f4f\",\r\n\t\t\"darkturquoise\": \"00ced1\",\r\n\t\t\"darkviolet\": \"9400d3\",\r\n\t\t\"deeppink\": \"ff1493\",\r\n\t\t\"deepskyblue\": \"00bfff\",\r\n\t\t\"dimgray\": \"696969\",\r\n\t\t\"dimgrey\": \"696969\",\r\n\t\t\"dodgerblue\": \"1e90ff\",\r\n\t\t\"firebrick\": \"b22222\",\r\n\t\t\"floralwhite\": \"fffaf0\",\r\n\t\t\"forestgreen\": \"228b22\",\r\n\t\t\"fuchsia\": \"f0f\",\r\n\t\t\"gainsboro\": \"dcdcdc\",\r\n\t\t\"ghostwhite\": \"f8f8ff\",\r\n\t\t\"gold\": \"ffd700\",\r\n\t\t\"goldenrod\": \"daa520\",\r\n\t\t\"gray\": \"808080\",\r\n\t\t\"green\": \"008000\",\r\n\t\t\"greenyellow\": \"adff2f\",\r\n\t\t\"grey\": \"808080\",\r\n\t\t\"honeydew\": \"f0fff0\",\r\n\t\t\"hotpink\": \"ff69b4\",\r\n\t\t\"indianred\": \"cd5c5c\",\r\n\t\t\"indigo\": \"4b0082\",\r\n\t\t\"ivory\": \"fffff0\",\r\n\t\t\"khaki\": \"f0e68c\",\r\n\t\t\"lavender\": \"e6e6fa\",\r\n\t\t\"lavenderblush\": \"fff0f5\",\r\n\t\t\"lawngreen\": \"7cfc00\",\r\n\t\t\"lemonchiffon\": \"fffacd\",\r\n\t\t\"lightblue\": \"add8e6\",\r\n\t\t\"lightcoral\": \"f08080\",\r\n\t\t\"lightcyan\": \"e0ffff\",\r\n\t\t\"lightgoldenrodyellow\": \"fafad2\",\r\n\t\t\"lightgray\": \"d3d3d3\",\r\n\t\t\"lightgreen\": \"90ee90\",\r\n\t\t\"lightgrey\": \"d3d3d3\",\r\n\t\t\"lightpink\": \"ffb6c1\",\r\n\t\t\"lightsalmon\": \"ffa07a\",\r\n\t\t\"lightseagreen\": \"20b2aa\",\r\n\t\t\"lightskyblue\": \"87cefa\",\r\n\t\t\"lightslategray\": \"789\",\r\n\t\t\"lightslategrey\": \"789\",\r\n\t\t\"lightsteelblue\": \"b0c4de\",\r\n\t\t\"lightyellow\": \"ffffe0\",\r\n\t\t\"lime\": \"0f0\",\r\n\t\t\"limegreen\": \"32cd32\",\r\n\t\t\"linen\": \"faf0e6\",\r\n\t\t\"magenta\": \"f0f\",\r\n\t\t\"maroon\": \"800000\",\r\n\t\t\"mediumaquamarine\": \"66cdaa\",\r\n\t\t\"mediumblue\": \"0000cd\",\r\n\t\t\"mediumorchid\": \"ba55d3\",\r\n\t\t\"mediumpurple\": \"9370db\",\r\n\t\t\"mediumseagreen\": \"3cb371\",\r\n\t\t\"mediumslateblue\": \"7b68ee\",\r\n\t\t\"mediumspringgreen\": \"00fa9a\",\r\n\t\t\"mediumturquoise\": \"48d1cc\",\r\n\t\t\"mediumvioletred\": \"c71585\",\r\n\t\t\"midnightblue\": \"191970\",\r\n\t\t\"mintcream\": \"f5fffa\",\r\n\t\t\"mistyrose\": \"ffe4e1\",\r\n\t\t\"moccasin\": \"ffe4b5\",\r\n\t\t\"navajowhite\": \"ffdead\",\r\n\t\t\"navy\": \"000080\",\r\n\t\t\"oldlace\": \"fdf5e6\",\r\n\t\t\"olive\": \"808000\",\r\n\t\t\"olivedrab\": \"6b8e23\",\r\n\t\t\"orange\": \"ffa500\",\r\n\t\t\"orangered\": \"ff4500\",\r\n\t\t\"orchid\": \"da70d6\",\r\n\t\t\"palegoldenrod\": \"eee8aa\",\r\n\t\t\"palegreen\": \"98fb98\",\r\n\t\t\"paleturquoise\": \"afeeee\",\r\n\t\t\"palevioletred\": \"db7093\",\r\n\t\t\"papayawhip\": \"ffefd5\",\r\n\t\t\"peachpuff\": \"ffdab9\",\r\n\t\t\"peru\": \"cd853f\",\r\n\t\t\"pink\": \"ffc0cb\",\r\n\t\t\"plum\": \"dda0dd\",\r\n\t\t\"powderblue\": \"b0e0e6\",\r\n\t\t\"purple\": \"800080\",\r\n\t\t\"rebeccapurple\": \"639\",\r\n\t\t\"red\": \"f00\",\r\n\t\t\"rosybrown\": \"bc8f8f\",\r\n\t\t\"royalblue\": \"4169e1\",\r\n\t\t\"saddlebrown\": \"8b4513\",\r\n\t\t\"salmon\": \"fa8072\",\r\n\t\t\"sandybrown\": \"f4a460\",\r\n\t\t\"seagreen\": \"2e8b57\",\r\n\t\t\"seashell\": \"fff5ee\",\r\n\t\t\"sienna\": \"a0522d\",\r\n\t\t\"silver\": \"c0c0c0\",\r\n\t\t\"skyblue\": \"87ceeb\",\r\n\t\t\"slateblue\": \"6a5acd\",\r\n\t\t\"slategray\": \"708090\",\r\n\t\t\"slategrey\": \"708090\",\r\n\t\t\"snow\": \"fffafa\",\r\n\t\t\"springgreen\": \"00ff7f\",\r\n\t\t\"steelblue\": \"4682b4\",\r\n\t\t\"tan\": \"d2b48c\",\r\n\t\t\"teal\": \"008080\",\r\n\t\t\"thistle\": \"d8bfd8\",\r\n\t\t\"tomato\": \"ff6347\",\r\n\t\t\"turquoise\": \"40e0d0\",\r\n\t\t\"violet\": \"ee82ee\",\r\n\t\t\"wheat\": \"f5deb3\",\r\n\t\t\"white\": \"fff\",\r\n\t\t\"whitesmoke\": \"f5f5f5\",\r\n\t\t\"yellow\": \"ff0\",\r\n\t\t\"yellowgreen\": \"9acd32\",\r\n\t\t\"transparent\": \"00000000\"\r\n\t};\r\n\t\r\n\tconst clamp = (n, a, b) => n < a ? a : (n > b ? b : n),\t// Clamp n in interval [a, b]\r\n\t\tround = (n, d) => {\t// Round n to nearest integer, or to d decimal places (if d is defined)\r\n\t\t\tvar p = Math.pow(10, d || 0);\r\n\t\t\treturn Math.round(n * p) / p;\r\n\t\t},\r\n\t\thi = n => clamp(parseInt(n, 16), 0, 255),\t// Convert 2-digit hex to int in interval [0, 255]\r\n\t\thf = n => clamp(round(parseInt(n, 16) / 255, 2), 0, 1),\t// Convert 2-digit hex to float with 2 decimal places in interval [0, 1]\r\n\t\tsi = n => clamp(round(parseFloat(n)), 0, 255),\t// Convert string to int in interval [0, 255]\r\n\t\tsf = n => clamp(round(parseFloat(n), 2), 0, 1),\t// Convert string to float with 2 decimal places in interval [0, 1]\r\n\t\tpi = n => clamp(round(parseFloat(n) / 100 * 255), 0, 255),\t// Convert percentage string to int in interval [0, 255]\r\n\t\tuf = n => clamp(parseFloat(n) / 360, 0, 1),\t// Convert hue string to float in interval [0, 1]\r\n\t\tpf = n => clamp(parseFloat(n) / 100, 0, 1);\t// Convert percentage string to float in interval [0, 1]\r\n\t\r\n\t// Convert hsl to rgb, alpha value gets passed straight through\r\n\t// h, s, l values are assumed to be in interval [0, 1]\r\n\t// Returns an object like { r, g, b, a }\r\n\t// http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\r\n\tfunction hslToRgb(h, s, l, a) {\r\n\t\tvar r, g, b,\r\n\t\t\thue = function(p, q, t) {\r\n\t\t\t\tif (t < 0) { t += 1; }\r\n\t\t\t\tif (t > 1) { t -= 1; }\r\n\t\t\t\tif (t < 1 / 6) { return p + (q - p) * 6 * t };\r\n\t\t\t\tif (t < 1 / 2) { return q; }\r\n\t\t\t\tif (t < 2 / 3) { return p + (q - p) * (2 / 3 - t) * 6 };\r\n\t\t\t\treturn p;\r\n\t\t\t};\r\n\t\tif (s == 0) {\r\n\t\t\tr = g = b = l;\r\n\t\t} else {\r\n\t\t\tvar q = l < 0.5 ? l * (1 + s) : l + s - l * s,\r\n\t\t\t\tp = 2 * l - q;\r\n\t\t\tr = hue(p, q, h + 1 / 3);\r\n\t\t\tg = hue(p, q, h);\r\n\t\t\tb = hue(p, q, h - 1 / 3);\r\n\t\t}\r\n\t\treturn { r: round(r * 255), g: round(g * 255), b: round(b * 255), a: a };\r\n\t}\r\n\treturn function(c) {\r\n\t\tvar o = { r: 0, g: 0, b: 0, a: 0 }, m = null;\r\n\t\tif (typeof c == \"string\") {\r\n\t\t\tif (c in names) { c = \"#\" + names[c]; }\r\n\t\t\tif ((m = c.match(/#([a-f0-9])([a-f0-9])([a-f0-9])$/i)) !== null) {\r\n\t\t\t\to = { r: hi(m[1] + m[1]), g: hi(m[2] + m[2]), b: hi(m[3] + m[3]), a: 1 };\r\n\t\t\t} else if ((m = c.match(/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i)) !== null) {\r\n\t\t\t\to = { r: hi(m[1]), g: hi(m[2]), b: hi(m[3]), a: 1 };\r\n\t\t\t} else if ((m = c.match(/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i)) !== null) {\r\n\t\t\t\to = { r: hi(m[1]), g: hi(m[2]), b: hi(m[3]), a: hf(m[4]) };\r\n\t\t\t} else if ((m = c.match(/rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)/)) !== null) {\r\n\t\t\t\to = { r: si(m[1]), g: si(m[2]), b: si(m[3]), a: 1 };\r\n\t\t\t} else if ((m = c.match(/rgb\\(\\s*(\\d{1,3}\\.?\\d?%)\\s*,\\s*(\\d{1,3}\\.?\\d?%)\\s*,\\s*(\\d{1,3}\\.?\\d?%)\\s*\\)/)) !== null) {\r\n\t\t\t\to = { r: pi(m[1]), g: pi(m[2]), b: pi(m[3]), a: 1 };\r\n\t\t\t} else if ((m = c.match(/rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d?\\.?\\d*?)?\\s*\\)/)) !== null) {\r\n\t\t\t\to = { r: si(m[1]), g: si(m[2]), b: si(m[3]), a: sf(m[4]) };\r\n\t\t\t} else if ((m = c.match(/rgba\\(\\s*(\\d{1,3}\\.?\\d?%)\\s*,\\s*(\\d{1,3}\\.?\\d?%)\\s*,\\s*(\\d{1,3}\\.?\\d?%)\\s*,\\s*(\\d?\\.?\\d*?)?\\s*\\)/)) !== null) {\r\n\t\t\t\to = { r: pi(m[1]), g: pi(m[2]), b: pi(m[3]), a: sf(m[4]) };\r\n\t\t\t} else if ((m = c.match(/hsl\\(\\s*(\\d{1,3}\\.?\\d?)\\s*,\\s*(\\d{1,3}\\.?\\d?%)\\s*,\\s*(\\d{1,3}\\.?\\d?%)\\s*\\)/)) !== null) {\r\n\t\t\t\to = hslToRgb(uf(m[1]), pf(m[2]), pf(m[3]), 1);\r\n\t\t\t} else if ((m = c.match(/hsla\\(\\s*(\\d{1,3}\\.?\\d?)\\s*,\\s*(\\d{1,3}\\.?\\d?%)\\s*,\\s*(\\d{1,3}\\.?\\d?%)\\s*,\\s*(\\d?\\.?\\d*?)?\\s*\\)/)) !== null) {\r\n\t\t\t\to = hslToRgb(uf(m[1]), pf(m[2]), pf(m[3]), sf(m[4]));\r\n\t\t\t}\r\n\t\t} else if (typeof c == \"object\") {\r\n\t\t\tif (c.r !== undefined && c.g != undefined && c.b !== undefined) {\r\n\t\t\t\to = { r: si(c.r), g: si(c.g), b: si(c.b), a: sf(c.a || 1) };\r\n\t\t\t} else if (c.h !== undefined && c.s !== undefined && c.l !== undefined) {\r\n\t\t\t\to = hslToRgb(uf(c.h), pf(c.s), pf(c.l), sf(c.a || 1));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn o;\r\n\t};\r\n}());\r\n\r\nif (true) {\r\n  module.exports = { parseColor };\r\n}\r\n\n\n//# sourceURL=webpack://@basementuniverse/particles-2d/./node_modules/@basementuniverse/parsecolor/parsecolor.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Memoize a function\n * @param {Function} f The function to memoize\n * @returns {Function} A memoized version of the function\n */\nconst memoize = f => {\n  var cache = {};\n  return function(...args) {\n    return cache[args] ?? (cache[args] = f.apply(this, args));\n  };\n};\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Round n to d decimal places\n * @param {number} n The number to round\n * @param {number} [d=0] The number of decimal places to round to\n * @return {number} A rounded number\n */\nconst round = (n, d = 0) => {\n  const p = Math.pow(10, d);\n  return Math.round(n * p + Number.EPSILON) / p;\n}\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback InterpolationFunction\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst npr = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * Generate all permutations of r elements from an array\n *\n * @example\n * ```js\n * permutations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 1],\n *   [2, 3],\n *   [3, 1],\n *   [3, 2]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each permutation\n * @return {Array<Array<*>>} An array of permutation arrays\n */\nconst permutations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...permutations(a.slice(0, i).concat(a.slice(i + 1)), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n}\n\n/**\n * Generate all combinations of r elements from an array\n *\n * @example\n * ```js\n * combinations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 3]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each combination\n * @return {Array<Array<*>>} An array of combination arrays\n */\nconst combinations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n};\n\n/**\n * Get a cartesian product of arrays\n *\n * @example\n * ```js\n * cartesian([1, 2, 3], ['a', 'b']);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, \"a\"],\n *   [1, \"b\"],\n *   [2, \"a\"],\n *   [2, \"b\"],\n *   [3, \"a\"],\n *   [3, \"b\"]\n * ]\n * ```\n */\nconst cartesian = (...arr) =>\n  arr.reduce(\n    (a, b) => a.flatMap(c => b.map(d => [...c, d])),\n    [[]]\n  );\n\n/**\n * A function for generating array values\n * @callback TimesFunction\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {TimesFunction} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip multiple arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {...Array<*>} a The arrays to zip\n * @return {Array<Array<*>>}\n */\nconst zip = (...a) => times(i => a.map(a => a[i]), Math.max(...a.map(a => a.length)));\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a The array to access\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Return the last element of an array without removing it\n * @param {Array<*>} a\n * @return {*} The last element from the array\n */\nconst peek = (a) => {\n  if (!a.length) {\n    return undefined;\n  }\n\n  return a[a.length - 1];\n};\n\n/**\n * Return the index for a given position in an unrolled 2d array\n * @param {number} x The x position\n * @param {number} y The y position\n * @param {number} w The width of the 2d array\n * @returns {number} The index in the unrolled array\n */\nconst ind = (x, y, w) => x + y * w;\n\n/**\n * Return the position for a given index in an unrolled 2d array\n * @param {number} i The index\n * @param {number} w The width of the 2d array\n * @returns {Array<number>} The position as a 2-tuple\n */\nconst pos = (i, w) => [i % w, Math.floor(i / w)];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\n/**\n * Flatten an object\n * @param {object} o\n * @param {string} concatenator The string to use for concatenating keys\n * @return {object} A flattened object\n */\nconst flat = (o, concatenator = '.') => {\n  return Object.keys(o).reduce((acc, key) => {\n    if (o[key] instanceof Date) {\n      return {\n        ...acc,\n        [key]: o[key].toISOString(),\n      };\n    }\n\n    if (typeof o[key] !== 'object' || !o[key]) {\n      return {\n        ...acc,\n        [key]: o[key],\n      };\n    }\n    const flattened = flat(o[key], concatenator);\n\n    return {\n      ...acc,\n      ...Object.keys(flattened).reduce(\n        (childAcc, childKey) => ({\n          ...childAcc,\n          [`${key}${concatenator}${childKey}`]: flattened[childKey],\n        }),\n        {}\n      ),\n    };\n  }, {});\n};\n\n/**\n * Unflatten an object\n * @param {object} o\n * @param {string} concatenator The string to check for in concatenated keys\n * @return {object} An un-flattened object\n */\nconst unflat = (o, concatenator = '.') => {\n  let result = {}, temp, substrings, property, i;\n\n  for (property in o) {\n    substrings = property.split(concatenator);\n    temp = result;\n    for (i = 0; i < substrings.length - 1; i++) {\n      if (!(substrings[i] in temp)) {\n        if (isFinite(substrings[i + 1])) {\n          temp[substrings[i]] = [];\n        } else {\n          temp[substrings[i]] = {};\n        }\n      }\n      temp = temp[substrings[i]];\n    }\n    temp[substrings[substrings.length - 1]] = o[property];\n  }\n\n  return result;\n};\n\n/**\n * A split predicate\n * @callback SplitPredicate\n * @param {any} value The current value\n * @return {boolean} True if the array should split at this index\n */\n\n/**\n * Split an array into sub-arrays based on a predicate\n * @param {Array<*>} array\n * @param {SplitPredicate} predicate\n * @return {Array<Array<*>>} An array of arrays\n */\nconst split = (array, predicate) => {\n  const result = [];\n  let current = [];\n  for (const value of array) {\n    if (predicate(value)) {\n      if (current.length) {\n        result.push(current);\n      }\n      current = [value];\n    } else {\n      current.push(value);\n    }\n  }\n  result.push(current);\n\n  return result;\n};\n\n/**\n * Pluck keys from an object\n * @param {object} o\n * @param {...string} keys The keys to pluck from the object\n * @return {object} An object containing the plucked keys\n */\nconst pluck = (o, ...keys) => {\n  return keys.reduce(\n    (result, key) => Object.assign(result, { [key]: o[key] }),\n    {}\n  );\n};\n\n/**\n * Exclude keys from an object\n * @param {object} o\n * @param {...string} keys The keys to exclude from the object\n * @return {object} An object containing all keys except excluded keys\n */\nconst exclude = (o, ...keys) => {\n  return Object.fromEntries(\n    Object.entries(o).filter(([key]) => !keys.includes(key))\n  );\n};\n\n/**\n * A key transform predicate\n * @callback KeyTransformFunction\n * @param {object} o The object being transformed\n * @param {string} path The current path in dot notation\n * @param {string} key The current key\n * @param {any} value The current value\n * @return {string|null} The transformed key, or null to omit the key\n */\n\n/**\n * A value transform predicate\n * @callback ValueTransformFunction\n * @param {object} o The object being transformed\n * @param {string} path The current path in dot notation\n * @param {string} key The current key\n * @param {any} value The current value\n * @return {any} The transformed value\n */\n\n/**\n * Recursively transform the keys and values of an object\n * @param {object} o The object to transform\n * @param {KeyTransformFunction} [kf=undefined] Optional key transform\n * @param {ValueTransformFunction} [vf=undefined] Optional value transform\n * @return {object} The transformed object\n */\nconst transform = (o, kf = undefined, vf = undefined) => {\n  const innerTransform = (obj, currentPath) => {\n    return Object.entries(obj).reduce((acc, [key, value]) => {\n      let newKey = key;\n      let newValue = value;\n      const path = currentPath ? `${currentPath}.${key}` : key;\n\n      if (\n        typeof newValue === 'object' &&\n        newValue !== null &&\n        !(newValue instanceof Date) &&\n        !Array.isArray(newValue)\n      ) {\n        newValue = innerTransform(newValue, path);\n      } else if (vf) {\n        newValue = vf(obj, path, key, value);\n      }\n      if (kf) {\n        newKey = kf(obj, path, key, newValue);\n        if (newKey === null) {\n          return acc;\n        }\n      }\n\n      return {\n        ...acc,\n        [newKey]: newValue,\n      };\n    }, {});\n  };\n\n  return innerTransform(o, '');\n};\n\nif (true) {\n  module.exports = {\n    memoize,\n    floatEquals,\n    clamp,\n    frac,\n    round,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    npr,\n    ncr,\n    permutations,\n    combinations,\n    cartesian,\n    times,\n    range,\n    zip,\n    at,\n    peek,\n    ind,\n    pos,\n    chunk,\n    shuffle,\n    flat,\n    unflat,\n    split,\n    pluck,\n    exclude,\n    transform,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/particles-2d/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Check if a value is a 2d vector\n * @param {*} value The value to check\n * @returns {boolean} True if value is a 2d vector, false otherwise\n */\nfunction isVec2(value) {\n  return (\n    value &&\n    typeof value === 'object' &&\n    'x' in value &&\n    typeof value.x === 'number' &&\n    'y' in value &&\n    typeof value.y === 'number' &&\n    !('z' in value)\n  );\n}\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Add multiple vectors\n * @param  {...any} v Vectors to add\n * @returns {vec2} The sum of the vectors\n */\nvec2.addm = (...v) => v.reduce((a, b) => vec2.add(a, b), vec2());\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Subtract multiple vectors\n * @param  {...any} v Vectors to subtract\n * @returns {vec2} The result of subtracting the vectors\n */\nvec2.subm = (...v) => v.reduce((a, b) => vec2.sub(a, b));\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Check if a value is a 3d vector\n * @param {*} value The value to check\n * @returns {boolean} True if value is a 3d vector, false otherwise\n */\nfunction isVec3(value) {\n  return (\n    value &&\n    typeof value === 'object' &&\n    'x' in value &&\n    typeof value.x === 'number' &&\n    'y' in value &&\n    typeof value.y === 'number' &&\n    'z' in value &&\n    typeof value.z === 'number'\n  );\n}\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Add multiple vectors\n * @param  {...any} v Vectors to add\n * @returns {vec3} The sum of the vectors\n */\nvec3.addm = (...v) => v.reduce((a, b) => vec3.add(a, b), vec3());\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Subtract multiple vectors\n * @param  {...any} v Vectors to subtract\n * @returns {vec3} The result of subtracting the vectors\n */\nvec3.subm = (...v) => v.reduce((a, b) => vec3.sub(a, b));\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Check if a value is a matrix\n * @param {*} value The value to check\n * @returns {boolean} True if value is a matrix, false otherwise\n */\nfunction isMat(value) {\n  return (\n    value &&\n    typeof value === 'object' &&\n    'm' in value &&\n    typeof value.m === 'number' &&\n    'n' in value &&\n    typeof value.n === 'number' &&\n    'entries' in value &&\n    Array.isArray(value.entries)\n  );\n}\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat, isVec2, isVec3, isMat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/particles-2d/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ForceFieldForces = exports.Collider = exports.Sink = exports.ForceField = exports.Attractor = exports.Emitter = exports.Particle = exports.ParticleSystem = void 0;\nconst canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ \"./node_modules/@basementuniverse/canvas-helpers/build/index.js\");\nconst _2d_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers/2d */ \"./node_modules/@basementuniverse/intersection-helpers/build/2d/index.js\");\nconst utilities_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers/utilities */ \"./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js\");\nconst parsecolor_1 = __webpack_require__(/*! @basementuniverse/parsecolor */ \"./node_modules/@basementuniverse/parsecolor/parsecolor.js\");\nconst utils_1 = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nfunction isVec2(value) {\n    return typeof value === 'object' && 'x' in value && 'y' in value;\n}\nfunction isRandomRange(value) {\n    return typeof value === 'object' && 'min' in value && 'max' in value;\n}\nfunction calculateRandomRange(range, integer = false) {\n    const r = integer ? utils_1.randomIntBetween : utils_1.randomBetween;\n    if (isVec2(range.min) && isVec2(range.max)) {\n        return (0, vec_1.vec2)(r(range.min.x, range.max.x), r(range.min.y, range.max.y));\n    }\n    return r(range.min, range.max);\n}\nfunction colorToString(color) {\n    var _a;\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${(_a = color.a) !== null && _a !== void 0 ? _a : 1})`;\n}\nfunction isColorObject(color) {\n    return (typeof color === 'object' && 'r' in color && 'g' in color && 'b' in color);\n}\nfunction prepareColor(color) {\n    if (Array.isArray(color)) {\n        return prepareColor(color[(0, utils_1.randomIntBetween)(0, color.length - 1)]);\n    }\n    if (isColorObject(color)) {\n        return colorToString(color);\n    }\n    return color;\n}\nfunction makeTransparent(color) {\n    if (isColorObject(color)) {\n        return { ...color, a: 0 };\n    }\n    const parsed = (0, parsecolor_1.parseColor)(color);\n    return { ...parsed, a: 0 };\n}\n/**\n * Check if a particle should be affected by an element based on the use setting\n * @param useSetting - The particle's use setting (boolean, string, or string[])\n * @param elementId - The optional id of the element\n * @returns true if the particle should be affected by this element\n */\nfunction shouldUseElement(useSetting, elementId) {\n    // false means don't use any\n    if (useSetting === false) {\n        return false;\n    }\n    // true means use all\n    if (useSetting === true) {\n        return true;\n    }\n    // string or string[] means use specific ids\n    if (typeof useSetting === 'string') {\n        return elementId === useSetting;\n    }\n    // Array of strings\n    if (Array.isArray(useSetting)) {\n        return elementId !== undefined && useSetting.includes(elementId);\n    }\n    return false;\n}\n// -----------------------------------------------------------------------------\n// Particle System\n// -----------------------------------------------------------------------------\nclass ParticleSystem {\n    constructor() {\n        this.particles = [];\n        this.emitters = [];\n        this.attractors = [];\n        this.forceFields = [];\n        this.colliders = [];\n        this.sinks = [];\n    }\n    get disposed() {\n        return ((this.particles.length === 0 ||\n            this.particles.every(particle => particle.disposed)) &&\n            (this.emitters.length === 0 ||\n                this.emitters.every(emitter => emitter.disposed)));\n    }\n    update(dt) {\n        // Update particles\n        this.particles.forEach(particle => {\n            if (!particle.disposed) {\n                particle.update(this, dt);\n            }\n        });\n        this.particles = this.particles.filter(particle => !particle.disposed);\n        // Update emitters\n        this.emitters.forEach(emitter => {\n            if (!emitter.disposed) {\n                emitter.update(this, dt);\n            }\n        });\n        this.emitters = this.emitters.filter(emitter => !emitter.disposed);\n        // Update attractors\n        this.attractors.forEach(attractor => {\n            if (!attractor.disposed) {\n                attractor.update(dt);\n            }\n        });\n        this.attractors = this.attractors.filter(attractor => !attractor.disposed);\n        // Update force fields\n        this.forceFields.forEach(forceField => {\n            if (!forceField.disposed) {\n                forceField.update(dt);\n            }\n        });\n        this.forceFields = this.forceFields.filter(forceField => !forceField.disposed);\n        // Update sinks\n        this.sinks.forEach(sink => {\n            if (!sink.disposed) {\n                sink.update(dt);\n            }\n        });\n        this.sinks = this.sinks.filter(sink => !sink.disposed);\n    }\n    draw(context) {\n        this.particles.forEach(particle => {\n            if (!particle.disposed) {\n                particle.draw(this, context);\n            }\n        });\n    }\n}\nexports.ParticleSystem = ParticleSystem;\n// -----------------------------------------------------------------------------\n// Particles\n// -----------------------------------------------------------------------------\nconst PARTICLE_DEFAULT_UPDATE_TYPES = [\n    'age',\n    'physics',\n    'direction',\n    'position',\n];\nconst PARTICLE_DEFAULT_DRAW_TYPES = ['transforms', 'fade', 'styles'];\nconst DEFAULT_PARTICLE_OPTIONS = {\n    useAttractors: true,\n    useForceFields: true,\n    useColliders: true,\n    useSinks: true,\n    maxSpeed: -1,\n    defaultUpdates: 'all',\n    defaultDraws: 'all',\n};\nfunction prepareDefaultUpdates(defaultUpdates) {\n    if (!Array.isArray(defaultUpdates)) {\n        return defaultUpdates === 'all' ? [...PARTICLE_DEFAULT_UPDATE_TYPES] : [];\n    }\n    return defaultUpdates.filter(update => PARTICLE_DEFAULT_UPDATE_TYPES.includes(update));\n}\nfunction prepareDefaultDraws(defaultDraws) {\n    if (!Array.isArray(defaultDraws)) {\n        return defaultDraws === 'all' ? [...PARTICLE_DEFAULT_DRAW_TYPES] : [];\n    }\n    return defaultDraws.filter(draw => PARTICLE_DEFAULT_DRAW_TYPES.includes(draw));\n}\nfunction prepareGlow(context, glow, actualColor = 'white') {\n    context.shadowColor = actualColor;\n    context.shadowBlur = glow.amount;\n    context.shadowOffsetX = 0;\n    context.shadowOffsetY = 0;\n}\nconst DEFAULT_PARTICLE_STYLE = {\n    style: 'dot',\n    color: 'white',\n};\nclass Particle {\n    constructor(\n    /**\n     * Initial position of the particle\n     */\n    position, \n    /**\n     * Initial velocity of the particle\n     */\n    velocity, \n    /**\n     * Size of the particle. This is used differently based on the style:\n     *\n     * - 'dot' style: we use the maximum of x and y as the radius\n     * - 'line' style: x is the length of the line, y is the line width\n     * - 'radial' style: we use the maximum of x and y as the radius\n     * - 'image' style: x and y are the width and height of the image\n     */\n    size, \n    /**\n     * Rotation of the particle in radians\n     *\n     * _(Note: not used for 'dot' and 'radial' styles)_\n     *\n     * If this is null, we calculate rotation based on velocity\n     */\n    rotation = null, \n    /**\n     * Lifespan of the particle in seconds\n     */\n    lifespan = 1, \n    /**\n     * Style options for the particle. This can be used to define a default\n     * rendering style and associated settings for the style\n     *\n     * The style can be one of:\n     *\n     * - 'dot': a simple dot with a color and optional glow\n     * - 'radial': a radial gradient with a color that fades to transparent\n     * - 'line': a line segment with a color, optional glow, and optional\n     *   rotation (the rotation can be relative or absolute)\n     * - 'image': an image with an optional rotation (the rotation can be\n     *   relative or absolute)\n     *\n     * If this is null, the particle will use the custom rendering hook if\n     * provided, or it will be invisible if no custom rendering is provided\n     *\n     * Omit this field or set it to undefined to use the default style\n     */\n    style, \n    /**\n     * Provide custom update logic and rendering logic here\n     */\n    options) {\n        var _a, _b, _c;\n        this.position = position;\n        this.velocity = velocity;\n        this.size = size;\n        this.rotation = rotation;\n        this.lifespan = lifespan;\n        this.age = 0;\n        this.style = null;\n        this.actualRotation = 0;\n        this.actualColor = '#fff';\n        this.actualColorTransparent = '#fff0';\n        this.actualGlowColor = '#fff';\n        this._disposed = false;\n        this.trailPositions = [];\n        if (style !== null) {\n            this.style = Object.assign({}, DEFAULT_PARTICLE_STYLE, style !== null && style !== void 0 ? style : {});\n        }\n        this.options = Object.assign({}, DEFAULT_PARTICLE_OPTIONS, options !== null && options !== void 0 ? options : {});\n        // Prepare colors\n        if (this.style && 'color' in this.style) {\n            this.actualColor = prepareColor(this.style.color);\n            this.actualColorTransparent = colorToString(makeTransparent(this.actualColor));\n            if ('glow' in this.style) {\n                this.actualGlowColor = prepareColor((_b = (_a = this.style.glow) === null || _a === void 0 ? void 0 : _a.color) !== null && _b !== void 0 ? _b : 'white');\n            }\n        }\n        // Initialize trail positions with current position if trail is enabled\n        if ((_c = this.style) === null || _c === void 0 ? void 0 : _c.trail) {\n            this.trailPositions.push((0, vec_1.vec2)(position));\n        }\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    get normalisedLifeRemaining() {\n        if (this.lifespan <= 0) {\n            return 0;\n        }\n        return (0, utils_1.unlerp)(this.age, 0, this.lifespan);\n    }\n    update(system, dt) {\n        var _a, _b;\n        const defaultUpdates = prepareDefaultUpdates(this.options.defaultUpdates);\n        // Optionally handle particle lifespan\n        if (defaultUpdates.includes('age')) {\n            this.age += dt;\n            // Dispose the particle when its lifespan is reached\n            if (this.age >= this.lifespan) {\n                this._disposed = true;\n            }\n        }\n        // Optionally handle particle physics, i.e. forces from attractors, force\n        // fields, colliders, and sinks\n        if (defaultUpdates.includes('physics')) {\n            if (this.options.useAttractors !== false) {\n                system.attractors.forEach(attractor => {\n                    if (!attractor.disposed &&\n                        shouldUseElement(this.options.useAttractors, attractor.id)) {\n                        attractor.applyForce(this, dt);\n                    }\n                });\n            }\n            if (this.options.useForceFields !== false) {\n                system.forceFields.forEach(forceField => {\n                    if (!forceField.disposed &&\n                        shouldUseElement(this.options.useForceFields, forceField.id)) {\n                        forceField.applyForce(this, system, dt);\n                    }\n                });\n            }\n            if (this.options.useSinks !== false) {\n                system.sinks.forEach(sink => {\n                    if (!sink.disposed &&\n                        shouldUseElement(this.options.useSinks, sink.id)) {\n                        sink.affect(this, dt);\n                    }\n                });\n            }\n            if (this.options.useColliders !== false) {\n                system.colliders.forEach(collider => {\n                    if (shouldUseElement(this.options.useColliders, collider.id)) {\n                        collider.handleCollision(this);\n                    }\n                });\n            }\n            // Cap velocity to maxSpeed if specified\n            if (this.options.maxSpeed > 0) {\n                const speed = vec_1.vec2.len(this.velocity);\n                if (speed > this.options.maxSpeed) {\n                    this.velocity = vec_1.vec2.scale(vec_1.vec2.nor(this.velocity), this.options.maxSpeed);\n                }\n            }\n        }\n        // Call custom update hook if provided\n        if (this.options.update) {\n            this.options.update.bind(this)(system, dt);\n        }\n        // Update rotation and, if configured, calculate rotation based on velocity\n        this.actualRotation = (_a = this.rotation) !== null && _a !== void 0 ? _a : 0;\n        if (defaultUpdates.includes('direction') && this.rotation === null) {\n            this.actualRotation = vec_1.vec2.rad(this.velocity);\n        }\n        // Optionally handle position integration over time\n        if (defaultUpdates.includes('position')) {\n            this.position = vec_1.vec2.add(this.position, vec_1.vec2.scale(this.velocity, dt));\n        }\n        // Update trail positions if trail is enabled\n        if (((_b = this.style) === null || _b === void 0 ? void 0 : _b.trail) && defaultUpdates.includes('position')) {\n            // Only add new position if we've moved far enough from the last position\n            const lastPosition = this.trailPositions[this.trailPositions.length - 1];\n            if (!lastPosition ||\n                (0, _2d_1.distance)(lastPosition, this.position) >=\n                    Particle.MINIMUM_TRAIL_MOVEMENT_THRESHOLD) {\n                this.trailPositions.push((0, vec_1.vec2)(this.position));\n                // Keep only the most recent positions based on trail length\n                while (this.trailPositions.length > this.style.trail.length) {\n                    this.trailPositions.shift();\n                }\n            }\n        }\n    }\n    drawTrail(context, particleAlpha = 1) {\n        var _a, _b, _c;\n        if (!((_a = this.style) === null || _a === void 0 ? void 0 : _a.trail) || this.trailPositions.length < 2) {\n            return;\n        }\n        const trail = this.style.trail;\n        const segments = this.trailPositions.length - 1;\n        // Determine trail color\n        const trailColor = trail.color\n            ? prepareColor(trail.color)\n            : this.style.style !== 'image' && 'color' in this.style\n                ? this.actualColor\n                : null;\n        if (!trailColor) {\n            return; // No valid color available\n        }\n        // Determine base width\n        const baseWidth = (_b = trail.width) !== null && _b !== void 0 ? _b : (this.style.style === 'line'\n            ? this.size.y\n            : Math.max(this.size.x, this.size.y));\n        context.save();\n        context.lineCap = 'round';\n        context.lineJoin = 'round';\n        // Draw trail segments\n        const widthDecay = Math.min(1, (_c = trail.widthDecay) !== null && _c !== void 0 ? _c : 1);\n        for (let i = 0; i < segments; i++) {\n            const start = this.trailPositions[i];\n            const end = this.trailPositions[i + 1];\n            // Calculate width based on decay\n            const progress = 1 - i / (segments - 1);\n            const decayFactor = 1 - progress * widthDecay;\n            const width = baseWidth * decayFactor;\n            // Calculate segment alpha based on fade settings\n            let alpha = 1;\n            if (trail.segmentFade) {\n                const fadeIn = trail.segmentFade.in\n                    ? Math.min(1, 1 - i / trail.segmentFade.in)\n                    : 1;\n                const fadeOut = trail.segmentFade.out\n                    ? Math.min(1, 1 - (segments - i) / trail.segmentFade.out)\n                    : 1;\n                alpha = Math.min(fadeIn, fadeOut);\n            }\n            // Draw segment\n            context.beginPath();\n            context.strokeStyle = trailColor;\n            context.lineWidth = width;\n            context.globalAlpha = alpha * particleAlpha;\n            context.moveTo(start.x, start.y);\n            context.lineTo(end.x, end.y);\n            context.stroke();\n        }\n        context.restore();\n    }\n    draw(system, context) {\n        var _a, _b, _c, _d, _e, _f;\n        const defaultDraws = prepareDefaultDraws(this.options.defaultDraws);\n        context.save();\n        // Optionally handle fade in/out effects\n        let fadeAlpha = 1;\n        if (defaultDraws.includes('fade') && ((_a = this.style) === null || _a === void 0 ? void 0 : _a.fade)) {\n            const fadeIn = this.style.fade.in === 0\n                ? 1\n                : (0, utils_1.clamp)((0, utils_1.unlerp)(0, this.style.fade.in, this.age), 0, 1);\n            const fadeOut = this.style.fade.out === 0\n                ? 1\n                : (0, utils_1.clamp)((0, utils_1.unlerp)(this.lifespan, this.lifespan - this.style.fade.out, this.age), 0, 1);\n            fadeAlpha = (0, utils_1.clamp)(fadeIn * fadeOut, 0, 1);\n        }\n        // Draw trail before applying particle transforms\n        if (defaultDraws.includes('styles') && ((_b = this.style) === null || _b === void 0 ? void 0 : _b.trail)) {\n            this.drawTrail(context, fadeAlpha);\n        }\n        // Optionally apply transforms\n        if (defaultDraws.includes('transforms')) {\n            context.translate(this.position.x, this.position.y);\n        }\n        context.globalAlpha = fadeAlpha;\n        // Call custom pre-draw hook if provided\n        if (this.options.preDraw) {\n            this.options.preDraw.bind(this)(system, context);\n        }\n        // Optionally render one of the default styles if configured\n        if (defaultDraws.includes('styles') && this.style !== null) {\n            switch (this.style.style) {\n                case 'dot':\n                    // Dot style renders a circle with a fill color\n                    if (this.style.glow) {\n                        prepareGlow(context, this.style.glow, this.actualGlowColor);\n                    }\n                    (0, canvas_helpers_1.circle)(context, (0, vec_1.vec2)(), Math.max(this.size.x, this.size.y) / 2, {\n                        fill: true,\n                        fillColor: this.actualColor,\n                        stroke: false,\n                    });\n                    break;\n                case 'radial':\n                    // Radial style renders a radial gradient circle\n                    const size = Math.max(this.size.x, this.size.y) / 2;\n                    const gradient = context.createRadialGradient(0, 0, 0, 0, 0, size);\n                    const startColor = this.actualColor;\n                    const endColor = this.actualColorTransparent;\n                    gradient.addColorStop(0, startColor);\n                    gradient.addColorStop(1, endColor);\n                    context.fillStyle = gradient;\n                    context.beginPath();\n                    context.arc(0, 0, size, 0, Math.PI * 2);\n                    context.fill();\n                    context.closePath();\n                    break;\n                case 'line':\n                    // Line style renders a line segment with a stroke color\n                    if (this.style.glow) {\n                        prepareGlow(context, this.style.glow, this.actualGlowColor);\n                    }\n                    const angle = ((_c = this.actualRotation) !== null && _c !== void 0 ? _c : 0) + ((_d = this.style.rotationOffset) !== null && _d !== void 0 ? _d : 0);\n                    const length = this.size.x;\n                    const lineWidth = this.size.y;\n                    const vector = vec_1.vec2.rot((0, vec_1.vec2)(length, 0), angle);\n                    (0, canvas_helpers_1.line)(context, vec_1.vec2.scale(vector, -0.5), vec_1.vec2.scale(vector, 0.5), {\n                        lineWidth,\n                        strokeColor: this.actualColor,\n                    });\n                    break;\n                case 'image':\n                    // Image style renders an image with optional rotation\n                    if (defaultDraws.includes('transforms')) {\n                        const angle = ((_e = this.actualRotation) !== null && _e !== void 0 ? _e : 0) + ((_f = this.style.rotationOffset) !== null && _f !== void 0 ? _f : 0);\n                        context.rotate(angle);\n                    }\n                    context.drawImage(this.style.image, -this.size.x / 2, -this.size.y / 2, this.size.x, this.size.y);\n                    break;\n            }\n        }\n        // Call custom post-draw hook if provided\n        if (this.options.postDraw) {\n            this.options.postDraw.bind(this)(system, context);\n        }\n        context.restore();\n    }\n}\nexports.Particle = Particle;\nParticle.MINIMUM_TRAIL_MOVEMENT_THRESHOLD = 5;\nconst DEFAULT_EMITTER_OPTIONS = {\n    particles: {\n        position: 'uniform',\n        speed: 0,\n        direction: 0,\n        size: (0, vec_1.vec2)(1),\n        rotation: null,\n        lifespan: 1,\n        style: DEFAULT_PARTICLE_STYLE,\n        options: DEFAULT_PARTICLE_OPTIONS,\n    },\n    emission: {\n        type: 'rate',\n        rate: 1,\n    },\n};\nclass Emitter {\n    constructor(position, size = (0, vec_1.vec2)(0, 0), lifespan = -1, options) {\n        this.position = position;\n        this.size = size;\n        this.lifespan = lifespan;\n        this.age = 0;\n        this.totalParticlesEmitted = 0;\n        this._disposed = false;\n        this.currentRate = 0;\n        this.lastRateChange = 0;\n        this.particlesToEmit = 0;\n        this.options = Object.assign({}, DEFAULT_EMITTER_OPTIONS, options !== null && options !== void 0 ? options : {});\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    update(system, dt) {\n        // Handle emitter aging and dispose if we've reached the lifespan\n        this.age += dt;\n        if (this.lifespan !== -1 && this.age >= this.lifespan) {\n            this._disposed = true;\n            return;\n        }\n        // Handle particle emission based on the type of emission configured\n        switch (this.options.emission.type) {\n            case 'rate':\n                // Rate mode emits particles continuously at a specified rate\n                // Handle random rate changes\n                this.lastRateChange += dt;\n                if (this.currentRate <= 0 ||\n                    this.lastRateChange >= Emitter.RANDOM_RATE_CHANGE_INTERVAL) {\n                    this.lastRateChange = 0;\n                    // The actual emission rate can be a fixed value or a random range\n                    this.currentRate = isRandomRange(this.options.emission.rate)\n                        ? calculateRandomRange(this.options.emission.rate)\n                        : this.options.emission.rate;\n                }\n                // Accumulate a fractional number of particles to emit\n                this.particlesToEmit += this.currentRate * dt;\n                // Emit particles if we have enough to emit\n                if (this.particlesToEmit >= 1) {\n                    // Get the whole number of particles to emit\n                    const n = Math.floor(this.particlesToEmit);\n                    // Subtract the number of particles, keeping the remainder\n                    this.particlesToEmit -= n;\n                    // Emit the particles\n                    this.emitParticles(system, n);\n                    this.totalParticlesEmitted += n;\n                }\n                break;\n            case 'burst':\n                // Burst mode emits a fixed or random number of particles at once (or\n                // after a delay) and then immediately disposes the emitter\n                if (!this.options.emission.delay ||\n                    this.age >= this.options.emission.delay) {\n                    // The number of particles to emit can be a fixed value or a random\n                    // range\n                    const n = isRandomRange(this.options.emission.n)\n                        ? calculateRandomRange(this.options.emission.n, true)\n                        : Math.ceil(this.options.emission.n);\n                    if (n > 0) {\n                        this.emitParticles(system, n);\n                        this.totalParticlesEmitted += n;\n                        // Keep trying to emit until we've emitted at least one particle\n                        this._disposed = true;\n                    }\n                }\n                break;\n            case 'custom':\n                // Custom mode allows for a custom function to determine how many\n                // particles to emit on each update\n                const n = Math.ceil(this.options.emission.f.bind(this)());\n                if (n > 0) {\n                    this.emitParticles(system, n);\n                    this.totalParticlesEmitted += n;\n                }\n                break;\n        }\n    }\n    emitParticles(system, n) {\n        for (let i = 0; i < n; i++) {\n            const particle = this.createParticle(system, i);\n            if (particle) {\n                system.particles.push(particle);\n            }\n        }\n    }\n    createParticle(system, n) {\n        // Generate position\n        let position;\n        if ((0, utilities_1.vectorAlmostZero)(this.size)) {\n            // Emitter size is zero, so use the exact emitter position\n            position = (0, vec_1.vec2)(this.position);\n        }\n        else {\n            switch (this.options.particles.position) {\n                case 'uniform':\n                    // Uniform distribution within the emitter area\n                    position = (0, vec_1.vec2)((0, utils_1.randomIntBetween)(this.position.x - this.size.x / 2, this.position.x + this.size.x / 2), (0, utils_1.randomIntBetween)(this.position.y - this.size.y / 2, this.position.y + this.size.y / 2));\n                    break;\n                case 'normal':\n                    // Normal distribution from the center of the emitter area\n                    position = (0, vec_1.vec2)((0, utils_1.cltRandomInt)(this.position.x - this.size.x / 2, this.position.x + this.size.x / 2), (0, utils_1.cltRandomInt)(this.position.y - this.size.y / 2, this.position.y + this.size.y / 2));\n                    break;\n                default:\n                    if (typeof this.options.particles.position === 'function') {\n                        // Custom position function\n                        position = this.options.particles.position.bind(this)(n);\n                    }\n                    else {\n                        // Something went wrong, fall back to emitter position\n                        position = (0, vec_1.vec2)(this.position);\n                    }\n            }\n        }\n        // Generate velocity\n        let speed;\n        if (typeof this.options.particles.speed === 'function') {\n            // Custom speed function\n            speed = this.options.particles.speed.bind(this)(n);\n        }\n        else if (isRandomRange(this.options.particles.speed)) {\n            // Random speed range\n            speed = calculateRandomRange(this.options.particles.speed, true);\n        }\n        else {\n            // Fixed speed\n            speed = this.options.particles.speed;\n        }\n        let direction;\n        if (typeof this.options.particles.direction === 'function') {\n            // Custom direction function\n            direction = this.options.particles.direction.bind(this)(n);\n        }\n        else if (isRandomRange(this.options.particles.direction)) {\n            // Random direction range\n            direction = calculateRandomRange(this.options.particles.direction);\n        }\n        else {\n            // Fixed direction\n            direction = this.options.particles.direction;\n        }\n        const velocity = vec_1.vec2.rot((0, vec_1.vec2)(speed, 0), direction);\n        // Generate size\n        let size;\n        if (typeof this.options.particles.size === 'function') {\n            // Custom size function\n            size = this.options.particles.size.bind(this)(n);\n        }\n        else if (isRandomRange(this.options.particles.size)) {\n            // Random size range\n            size = calculateRandomRange(this.options.particles.size);\n        }\n        else {\n            // Fixed size\n            size = this.options.particles.size;\n        }\n        // Generate rotation\n        let rotation;\n        if (this.options.particles.rotation === null) {\n            rotation = null;\n        }\n        else if (typeof this.options.particles.rotation === 'function') {\n            // Custom rotation function\n            rotation = this.options.particles.rotation.bind(this)(n);\n        }\n        else if (isRandomRange(this.options.particles.rotation)) {\n            // Random rotation range\n            rotation = calculateRandomRange(this.options.particles.rotation);\n        }\n        else {\n            // Fixed rotation\n            rotation = this.options.particles.rotation;\n        }\n        // Generate lifespan\n        let lifespan;\n        if (typeof this.options.particles.lifespan === 'function') {\n            // Custom lifespan function\n            lifespan = this.options.particles.lifespan.bind(this)(n);\n        }\n        else if (isRandomRange(this.options.particles.lifespan)) {\n            // Random lifespan range\n            lifespan = calculateRandomRange(this.options.particles.lifespan);\n        }\n        else {\n            // Fixed lifespan\n            lifespan = this.options.particles.lifespan;\n        }\n        return new Particle(position, velocity, size, rotation, lifespan, this.options.particles.style, this.options.particles.options);\n    }\n}\nexports.Emitter = Emitter;\nEmitter.RANDOM_RATE_CHANGE_INTERVAL = 1;\n// -----------------------------------------------------------------------------\n// Attractors\n// -----------------------------------------------------------------------------\nclass Attractor {\n    constructor(position, range = 100, force = 1, falloff = 1, lifespan = -1, id) {\n        this.position = position;\n        this.range = range;\n        this.force = force;\n        this.falloff = falloff;\n        this.lifespan = lifespan;\n        this.id = id;\n        this.age = 0;\n        this._disposed = false;\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    applyForce(particle, dt) {\n        // Calculate distance to the particle\n        const d = (0, _2d_1.distance)(this.position, particle.position);\n        if (d > this.range) {\n            return; // Particle is out of range\n        }\n        // Prevent divide-by-zero with a small minimum distance\n        const minDistance = 1;\n        const safeDistance = Math.max(d, minDistance);\n        // Calculate direction vector from particle to attractor\n        const direction = vec_1.vec2.sub(this.position, particle.position);\n        const normalizedDirection = vec_1.vec2.nor(direction);\n        // Use configurable falloff instead of fixed inverse square law\n        // Higher falloff values create steeper gradients (stronger close-range effects)\n        // Lower falloff values create gentler gradients (more uniform force fields)\n        const distanceFactor = 1 / Math.pow(safeDistance, this.falloff);\n        // Apply smooth range falloff at the boundary\n        const rangeFactor = d / this.range;\n        const rangeFalloff = Math.max(0, 1 - rangeFactor * rangeFactor);\n        // Calculate final force vector\n        const finalForceStrength = this.force * distanceFactor * rangeFalloff;\n        const forceVector = vec_1.vec2.scale(normalizedDirection, finalForceStrength);\n        // Apply the force to the particle's velocity\n        particle.velocity = vec_1.vec2.add(particle.velocity, vec_1.vec2.scale(forceVector, dt));\n    }\n    update(dt) {\n        this.age += dt;\n        // Dispose the attractor when its lifespan is reached\n        if (this.lifespan !== -1 && this.age >= this.lifespan) {\n            this._disposed = true;\n        }\n    }\n}\nexports.Attractor = Attractor;\n// -----------------------------------------------------------------------------\n// Forcefields\n// -----------------------------------------------------------------------------\nclass ForceField {\n    constructor(force = (0, vec_1.vec2)(0, 0), lifespan = -1, customForce, customForceParams, id) {\n        this.force = force;\n        this.lifespan = lifespan;\n        this.customForce = customForce;\n        this.customForceParams = customForceParams;\n        this.id = id;\n        this.age = 0;\n        this._disposed = false;\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    applyForce(particle, system, dt) {\n        // If a custom force function is provided, use it instead of the default\n        if (this.customForce) {\n            if (typeof this.customForce === 'string') {\n                exports.ForceFieldForces[this.customForce].bind(particle)(system, this, dt);\n            }\n            else if (typeof this.customForce === 'function') {\n                this.customForce.bind(particle)(system, this, dt);\n            }\n        }\n        else {\n            // Default behavior: apply the force vector\n            particle.velocity = vec_1.vec2.add(particle.velocity, vec_1.vec2.scale(this.force, dt));\n        }\n    }\n    update(dt) {\n        this.age += dt;\n        // Dispose the force field when its lifespan is reached\n        if (this.lifespan !== -1 && this.age >= this.lifespan) {\n            this._disposed = true;\n        }\n    }\n}\nexports.ForceField = ForceField;\n// -----------------------------------------------------------------------------\n// Sinks\n// -----------------------------------------------------------------------------\nclass Sink {\n    constructor(position, range = 50, strength = 1, falloff = 1, mode = 'fade', lifespan = -1, id) {\n        this.position = position;\n        this.range = range;\n        this.strength = strength;\n        this.falloff = falloff;\n        this.mode = mode;\n        this.lifespan = lifespan;\n        this.id = id;\n        this.age = 0;\n        this._disposed = false;\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    affect(particle, dt) {\n        // Calculate distance to the particle\n        const d = (0, _2d_1.distance)(this.position, particle.position);\n        if (d > this.range) {\n            return; // Particle is out of range\n        }\n        // Instant mode: immediately set particle age to its lifespan\n        if (this.mode === 'instant') {\n            particle.age = particle.lifespan;\n            return;\n        }\n        // Fade mode: accelerate particle aging based on strength and falloff\n        // Prevent divide-by-zero with a small minimum distance\n        const minDistance = 1;\n        const safeDistance = Math.max(d, minDistance);\n        // Use configurable falloff to create distance-based effect gradient\n        // Higher falloff values create steeper gradients (stronger at center)\n        // Lower falloff values create gentler gradients (more uniform effect)\n        const distanceFactor = 1 / Math.pow(safeDistance, this.falloff);\n        // Apply smooth range falloff at the boundary\n        const rangeFactor = d / this.range;\n        const rangeFalloff = Math.max(0, 1 - rangeFactor * rangeFactor);\n        // Calculate final aging multiplier\n        const agingMultiplier = this.strength * distanceFactor * rangeFalloff;\n        // Accelerate particle aging\n        particle.age += agingMultiplier * dt;\n    }\n    update(dt) {\n        this.age += dt;\n        // Dispose the sink when its lifespan is reached\n        if (this.lifespan !== -1 && this.age >= this.lifespan) {\n            this._disposed = true;\n        }\n    }\n}\nexports.Sink = Sink;\nclass Collider {\n    constructor(geometry, restitution = 0.5, friction = 0.5, randomness = 0, id) {\n        this.geometry = geometry;\n        this.restitution = restitution;\n        this.friction = friction;\n        this.randomness = randomness;\n        this.id = id;\n    }\n    handleCollision(particle) {\n        var _a, _b;\n        // Broad phase: first check if the point is in the collider's AABB\n        const geometryAABB = (0, _2d_1.aabb)(this.geometry);\n        if (geometryAABB === null) {\n            return; // Invalid polygon\n        }\n        if (!(0, _2d_1.pointInAABB)(particle.position, geometryAABB)) {\n            return; // Particle is outside the collider's AABB\n        }\n        // Narrow phase: check if the particle collides with the collider geometry\n        let collisionResult;\n        switch (this.geometry.type) {\n            case 'circle':\n                collisionResult = (0, _2d_1.pointInCircle)(particle.position, {\n                    position: this.geometry.position,\n                    radius: this.geometry.radius,\n                });\n                break;\n            case 'rectangle':\n                collisionResult = (0, _2d_1.pointInRectangle)(particle.position, {\n                    position: this.geometry.position,\n                    size: this.geometry.size,\n                    rotation: (_a = this.geometry.rotation) !== null && _a !== void 0 ? _a : 0,\n                });\n                break;\n            case 'polygon':\n                collisionResult = (0, _2d_1.pointInPolygon)(particle.position, {\n                    vertices: this.geometry.vertices,\n                });\n                break;\n        }\n        if (collisionResult === null || !collisionResult.intersects) {\n            return; // Invalid polygon or no intersection\n        }\n        // Handle the collision\n        // The collider has a friction value which is used to reduce the particle's\n        // velocity after the collision\n        // The collider has a restitution value which is used to bounce the particle\n        // off the collider surface\n        const normal = (_b = collisionResult.normal) !== null && _b !== void 0 ? _b : (0, vec_1.vec2)(0, 0);\n        const relativeVelocity = vec_1.vec2.sub(particle.velocity, (0, vec_1.vec2)(0, 0));\n        const velocityAlongNormal = vec_1.vec2.dot(relativeVelocity, normal);\n        if (velocityAlongNormal > 0) {\n            return; // Particle is moving away from the collider, no collision\n        }\n        // Calculate the impulse to apply to the particle\n        const impulseMagnitude = -(1 + this.restitution) * velocityAlongNormal;\n        const impulse = vec_1.vec2.scale(normal, impulseMagnitude);\n        // Apply the impulse to the particle's velocity\n        particle.velocity = vec_1.vec2.add(particle.velocity, impulse);\n        // Apply randomness to the particle's velocity\n        if (this.randomness > 0) {\n            // Get a random angle between -PI and PI, scaled by randomness\n            const randomAngle = (0, utils_1.randomBetween)(-Math.PI * this.randomness, Math.PI * this.randomness);\n            particle.velocity = vec_1.vec2.rot(particle.velocity, randomAngle);\n        }\n        // Apply friction to the particle's velocity\n        const frictionImpulse = vec_1.vec2.scale(vec_1.vec2.sub(relativeVelocity, vec_1.vec2.scale(normal, velocityAlongNormal)), -this.friction);\n        particle.velocity = vec_1.vec2.add(particle.velocity, frictionImpulse);\n    }\n}\nexports.Collider = Collider;\n// -----------------------------------------------------------------------------\n// Built-in force-field custom force functions\n// -----------------------------------------------------------------------------\nexports.ForceFieldForces = {\n    /**\n     * Built-in force-field function that creates a wave effect, causing particles\n     * to oscillate back and forth perpendicular to the force-field's force\n     * direction.\n     *\n     * The frequency and amplitude of the wave can be configured via the force\n     * field's customForceParams:\n     *\n     * - frequency: controls how many oscillations occur per second (default: 1)\n     * - amplitude: controls how far particles are pushed from side to side (default: 50)\n     */\n    wave: function (_system, forceField, dt) {\n        var _a, _b, _c, _d;\n        const frequency = (_b = (_a = forceField.customForceParams) === null || _a === void 0 ? void 0 : _a.frequency) !== null && _b !== void 0 ? _b : 1;\n        const amplitude = (_d = (_c = forceField.customForceParams) === null || _c === void 0 ? void 0 : _c.amplitude) !== null && _d !== void 0 ? _d : 50;\n        // Calculate perpendicular direction to the force field's force vector\n        const forceDirection = vec_1.vec2.nor(forceField.force);\n        const perpendicularDirection = vec_1.vec2.rotf(forceDirection, 1);\n        // Calculate wave offset based on time and frequency\n        const time = forceField.age;\n        const waveOffset = Math.sin(time * frequency * 2 * Math.PI) * amplitude;\n        // Apply the wave force to the particle's velocity\n        this.velocity = vec_1.vec2.add(this.velocity, vec_1.vec2.scale(perpendicularDirection, waveOffset * dt));\n    },\n    /**\n     * Built-in force-field function that creates a vortex effect, causing\n     * particles to spiral around a center point.\n     *\n     * The center point, strength and range of the vortex can be configured via\n     * the force field's customForceParams:\n     *\n     * - center: the center point of the vortex (ignore this force if undefined)\n     * - strength: controls how strongly particles are pulled into the vortex\n     * - range: controls how far from the center the vortex effect is applied\n     * - clockwise: if true, particles will spiral clockwise\n     */\n    vortex: function (_system, forceField, dt) {\n        var _a, _b, _c, _d, _e, _f;\n        const center = (_a = forceField.customForceParams) === null || _a === void 0 ? void 0 : _a.center;\n        if (!center || !isVec2(center)) {\n            return; // No center defined, or center is not a vec2\n        }\n        const strength = (_c = (_b = forceField.customForceParams) === null || _b === void 0 ? void 0 : _b.strength) !== null && _c !== void 0 ? _c : 1;\n        const range = (_e = (_d = forceField.customForceParams) === null || _d === void 0 ? void 0 : _d.range) !== null && _e !== void 0 ? _e : 100;\n        // Calculate distance to the particle\n        const d = (0, _2d_1.distance)(center, this.position);\n        if (d > range) {\n            return; // Particle is out of range\n        }\n        // Calculate direction vector from particle to force field center\n        const direction = vec_1.vec2.sub(this.position, center);\n        const normalizedDirection = vec_1.vec2.nor(direction);\n        // Calculate perpendicular direction for vortex effect\n        const perpendicularDirection = ((_f = forceField.customForceParams) === null || _f === void 0 ? void 0 : _f.clockwise)\n            ? vec_1.vec2.rotf(normalizedDirection, 1)\n            : vec_1.vec2.rotf(normalizedDirection, -1);\n        // Use inverse distance falloff for stronger effect closer to the center\n        const distanceFactor = 1 / Math.max(d, 1); // Prevent divide-by-zero\n        // Calculate final force vector\n        const finalForceStrength = strength * distanceFactor;\n        const forceVector = vec_1.vec2.scale(perpendicularDirection, finalForceStrength);\n        // Apply the force to the particle's velocity\n        this.velocity = vec_1.vec2.add(this.velocity, vec_1.vec2.scale(forceVector, dt));\n    },\n    /**\n     * Built-in force-field function that creates an orbital effect, causing\n     * particles to orbit around a center point in a more circular path.\n     *\n     * The center point, strength and range of the orbital effect can be\n     * configured via the force field's customForceParams:\n     *\n     * - center: the center point of the orbital effect (ignore this force if\n     *   undefined)\n     * - strength: controls how strongly particles are pulled into orbit\n     * - range: controls how far from the center the orbital effect is applied\n     */\n    orbital: function (_system, forceField, dt) {\n        var _a, _b, _c, _d, _e;\n        const center = (_a = forceField.customForceParams) === null || _a === void 0 ? void 0 : _a.center;\n        if (!center || !isVec2(center)) {\n            return; // No center defined, or center is not a vec2\n        }\n        const strength = (_c = (_b = forceField.customForceParams) === null || _b === void 0 ? void 0 : _b.strength) !== null && _c !== void 0 ? _c : 1;\n        const range = (_e = (_d = forceField.customForceParams) === null || _d === void 0 ? void 0 : _d.range) !== null && _e !== void 0 ? _e : 100;\n        // Calculate distance to the particle\n        const d = (0, _2d_1.distance)(center, this.position);\n        if (d > range) {\n            return; // Particle is out of range\n        }\n        // Calculate direction vector from particle to force field center\n        const direction = vec_1.vec2.sub(center, this.position);\n        const normalizedDirection = vec_1.vec2.nor(direction);\n        // Use inverse distance falloff for stronger effect closer to the center\n        const distanceFactor = 1 / Math.max(d, 1); // Prevent divide-by-zero\n        // Calculate final force vector\n        const finalForceStrength = strength * distanceFactor;\n        const forceVector = vec_1.vec2.scale(normalizedDirection, finalForceStrength);\n        // Apply the force to the particle's velocity\n        this.velocity = vec_1.vec2.add(this.velocity, vec_1.vec2.scale(forceVector, dt));\n    },\n    /**\n     * Built-in force-field function that creates a vector field effect using\n     * noise to create complex, flowing motion patterns.\n     *\n     * The vector field parameters can be configured via the force field's\n     * customForceParams:\n     *\n     * - noise: a noise function with signature:\n     *   `(x: number, y: number, z: number) => number`\n     *   (returns value in range [-1, 1])\n     * - noiseScale: controls the size of noise features (default: 0.01)\n     *   - smaller values = larger, smoother features\n     *   - larger values = smaller, more chaotic features\n     * - timeScale: controls how quickly the field changes over time (default: 0.1)\n     *   - represents the speed of movement through the z-dimension of noise\n     * - forceAmount: controls how strongly particles are affected (default: 100)\n     */\n    vectorField: function (system, forceField, dt) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const noise = (_a = forceField.customForceParams) === null || _a === void 0 ? void 0 : _a.noise;\n        if (!noise || typeof noise !== 'function') {\n            return; // No noise function defined\n        }\n        const noiseScale = (_c = (_b = forceField.customForceParams) === null || _b === void 0 ? void 0 : _b.noiseScale) !== null && _c !== void 0 ? _c : 0.01;\n        const timeScale = (_e = (_d = forceField.customForceParams) === null || _d === void 0 ? void 0 : _d.timeScale) !== null && _e !== void 0 ? _e : 0.1;\n        const forceAmount = (_g = (_f = forceField.customForceParams) === null || _f === void 0 ? void 0 : _f.forceAmount) !== null && _g !== void 0 ? _g : 100;\n        // Sample noise at particle position for x and y components of the force\n        // Use the force field's age to animate the field over time\n        const time = forceField.age * timeScale;\n        // Sample noise twice with slight offset to get independent x and y values\n        const noiseX = noise(this.position.x * noiseScale, this.position.y * noiseScale, time);\n        const noiseY = noise(this.position.x * noiseScale + 1000, // Offset to decorrelate x and y\n        this.position.y * noiseScale + 1000, time);\n        // Convert noise values (in range [-1, 1]) to force vector\n        const forceVector = (0, vec_1.vec2)(noiseX * forceAmount, noiseY * forceAmount);\n        // Apply the force to the particle's velocity\n        this.velocity = vec_1.vec2.add(this.velocity, vec_1.vec2.scale(forceVector, dt));\n    },\n    /**\n     * Built-in force-field function that creates a turbulence effect using\n     * random forces to create chaotic, jittery motion.\n     *\n     * The turbulence parameters can be configured via the force field's\n     * customForceParams:\n     *\n     * - strength: controls how strongly particles are affected (default: 100)\n     * - frequency: controls how often the random force changes (default: 10)\n     *   - higher values = more rapid changes in direction\n     *   - lower values = slower, more flowing changes\n     */\n    turbulence: function (_system, forceField, dt) {\n        var _a, _b, _c, _d;\n        const strength = (_b = (_a = forceField.customForceParams) === null || _a === void 0 ? void 0 : _a.strength) !== null && _b !== void 0 ? _b : 100;\n        const frequency = (_d = (_c = forceField.customForceParams) === null || _c === void 0 ? void 0 : _c.frequency) !== null && _d !== void 0 ? _d : 10;\n        // Use time and frequency to create variation\n        const time = forceField.age * frequency;\n        // Create pseudo-random but smooth values based on time and particle position\n        // This ensures turbulence is consistent for a given particle at a given time\n        const seed = this.position.x * 12.9898 + this.position.y * 78.233 + time;\n        const randomX = Math.abs(Math.sin(seed) * 43758.5453) % 1;\n        const randomY = Math.abs(Math.sin(seed + 1) * 43758.5453) % 1;\n        // Convert to range [-1, 1]\n        const forceX = (randomX * 2 - 1) * strength;\n        const forceY = (randomY * 2 - 1) * strength;\n        const forceVector = (0, vec_1.vec2)(forceX, forceY);\n        // Apply the force to the particle's velocity\n        this.velocity = vec_1.vec2.add(this.velocity, vec_1.vec2.scale(forceVector, dt));\n    },\n    /**\n     * Built-in force-field function that creates a drag effect, simulating\n     * air resistance or friction that slows particles over time.\n     *\n     * The drag parameters can be configured via the force field's\n     * customForceParams:\n     *\n     * - coefficient: controls how much drag is applied (default: 0.5)\n     *   - 0 = no drag\n     *   - 1 = maximum drag (particles slow to a stop quickly)\n     *   - higher values = even stronger drag\n     */\n    drag: function (_system, forceField, dt) {\n        var _a, _b;\n        const coefficient = (_b = (_a = forceField.customForceParams) === null || _a === void 0 ? void 0 : _a.coefficient) !== null && _b !== void 0 ? _b : 0.5;\n        // Apply drag force proportional to velocity (opposite direction)\n        // F_drag = -coefficient * velocity\n        const dragForce = vec_1.vec2.scale(this.velocity, -coefficient);\n        // Apply the force to the particle's velocity\n        this.velocity = vec_1.vec2.add(this.velocity, vec_1.vec2.scale(dragForce, dt));\n    },\n    /**\n     * Built-in force-field function that implements boids flocking behavior,\n     * causing particles to exhibit emergent group dynamics.\n     *\n     * Implements three classic boids rules:\n     * - Separation: avoid crowding neighbors\n     * - Alignment: steer towards average heading of neighbors\n     * - Cohesion: steer towards average position of neighbors\n     *\n     * The boids parameters can be configured via the force field's\n     * customForceParams:\n     *\n     * - separationDistance: how close is too close (default: 25)\n     * - alignmentDistance: range for alignment behavior (default: 50)\n     * - cohesionDistance: range for cohesion behavior (default: 50)\n     * - separationWeight: strength of separation force (default: 1.5)\n     * - alignmentWeight: strength of alignment force (default: 1.0)\n     * - cohesionWeight: strength of cohesion force (default: 1.0)\n     *\n     * WARNING: This force function checks each particle against all others in\n     * the system, resulting in O(n²) complexity. Only use with relatively small\n     * particle counts (recommended: < 200 particles). For larger systems,\n     * consider implementing custom boids behavior with spatial optimization.\n     */\n    boids: function (system, forceField, dt) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        const separationDistance = (_b = (_a = forceField.customForceParams) === null || _a === void 0 ? void 0 : _a.separationDistance) !== null && _b !== void 0 ? _b : 25;\n        const alignmentDistance = (_d = (_c = forceField.customForceParams) === null || _c === void 0 ? void 0 : _c.alignmentDistance) !== null && _d !== void 0 ? _d : 50;\n        const cohesionDistance = (_f = (_e = forceField.customForceParams) === null || _e === void 0 ? void 0 : _e.cohesionDistance) !== null && _f !== void 0 ? _f : 50;\n        const separationWeight = (_h = (_g = forceField.customForceParams) === null || _g === void 0 ? void 0 : _g.separationWeight) !== null && _h !== void 0 ? _h : 1.5;\n        const alignmentWeight = (_k = (_j = forceField.customForceParams) === null || _j === void 0 ? void 0 : _j.alignmentWeight) !== null && _k !== void 0 ? _k : 1.0;\n        const cohesionWeight = (_m = (_l = forceField.customForceParams) === null || _l === void 0 ? void 0 : _l.cohesionWeight) !== null && _m !== void 0 ? _m : 1.0;\n        let separationForce = (0, vec_1.vec2)(0, 0);\n        let alignmentForce = (0, vec_1.vec2)(0, 0);\n        let cohesionForce = (0, vec_1.vec2)(0, 0);\n        let separationCount = 0;\n        let alignmentCount = 0;\n        let cohesionCount = 0;\n        // Check all other particles\n        for (const other of system.particles) {\n            if (other === this || other.disposed) {\n                continue;\n            }\n            const d = (0, _2d_1.distance)(this.position, other.position);\n            // Separation: avoid crowding neighbors\n            if (d < separationDistance && d > 0) {\n                const diff = vec_1.vec2.sub(this.position, other.position);\n                const normalized = vec_1.vec2.nor(diff);\n                // Weight by distance (closer = stronger force)\n                const weighted = vec_1.vec2.scale(normalized, 1 / d);\n                separationForce = vec_1.vec2.add(separationForce, weighted);\n                separationCount++;\n            }\n            // Alignment: steer towards average heading of neighbors\n            if (d < alignmentDistance) {\n                alignmentForce = vec_1.vec2.add(alignmentForce, other.velocity);\n                alignmentCount++;\n            }\n            // Cohesion: steer towards average position of neighbors\n            if (d < cohesionDistance) {\n                cohesionForce = vec_1.vec2.add(cohesionForce, other.position);\n                cohesionCount++;\n            }\n        }\n        // Calculate average forces\n        if (separationCount > 0) {\n            separationForce = vec_1.vec2.scale(vec_1.vec2.nor(separationForce), separationWeight);\n        }\n        if (alignmentCount > 0) {\n            alignmentForce = vec_1.vec2.scale(alignmentForce, 1 / alignmentCount);\n            // Steer towards average velocity\n            alignmentForce = vec_1.vec2.sub(alignmentForce, this.velocity);\n            alignmentForce = vec_1.vec2.scale(vec_1.vec2.nor(alignmentForce), alignmentWeight);\n        }\n        if (cohesionCount > 0) {\n            cohesionForce = vec_1.vec2.scale(cohesionForce, 1 / cohesionCount);\n            // Steer towards average position\n            cohesionForce = vec_1.vec2.sub(cohesionForce, this.position);\n            cohesionForce = vec_1.vec2.scale(vec_1.vec2.nor(cohesionForce), cohesionWeight);\n        }\n        // Combine all forces\n        let totalForce = vec_1.vec2.add(separationForce, alignmentForce);\n        totalForce = vec_1.vec2.add(totalForce, cohesionForce);\n        // Apply the force to the particle's velocity\n        this.velocity = vec_1.vec2.add(this.velocity, vec_1.vec2.scale(totalForce, dt));\n    },\n};\n\n\n//# sourceURL=webpack://@basementuniverse/particles-2d/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});