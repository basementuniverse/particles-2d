/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Memoize a function\n * @param {Function} f The function to memoize\n * @returns {Function} A memoized version of the function\n */\nconst memoize = f => {\n  var cache = {};\n  return function(...args) {\n    return cache[args] ?? (cache[args] = f.apply(this, args));\n  };\n};\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Round n to d decimal places\n * @param {number} n The number to round\n * @param {number} [d=0] The number of decimal places to round to\n * @return {number} A rounded number\n */\nconst round = (n, d = 0) => {\n  const p = Math.pow(10, d);\n  return Math.round(n * p + Number.EPSILON) / p;\n}\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback InterpolationFunction\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst npr = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * Generate all permutations of r elements from an array\n *\n * @example\n * ```js\n * permutations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 1],\n *   [2, 3],\n *   [3, 1],\n *   [3, 2]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each permutation\n * @return {Array<Array<*>>} An array of permutation arrays\n */\nconst permutations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...permutations(a.slice(0, i).concat(a.slice(i + 1)), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n}\n\n/**\n * Generate all combinations of r elements from an array\n *\n * @example\n * ```js\n * combinations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 3]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each combination\n * @return {Array<Array<*>>} An array of combination arrays\n */\nconst combinations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n};\n\n/**\n * Get a cartesian product of arrays\n *\n * @example\n * ```js\n * cartesian([1, 2, 3], ['a', 'b']);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, \"a\"],\n *   [1, \"b\"],\n *   [2, \"a\"],\n *   [2, \"b\"],\n *   [3, \"a\"],\n *   [3, \"b\"]\n * ]\n * ```\n */\nconst cartesian = (...arr) =>\n  arr.reduce(\n    (a, b) => a.flatMap(c => b.map(d => [...c, d])),\n    [[]]\n  );\n\n/**\n * A function for generating array values\n * @callback TimesFunction\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {TimesFunction} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip multiple arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {...Array<*>} a The arrays to zip\n * @return {Array<Array<*>>}\n */\nconst zip = (...a) => times(i => a.map(a => a[i]), Math.max(...a.map(a => a.length)));\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a The array to access\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Return the last element of an array without removing it\n * @param {Array<*>} a\n * @return {*} The last element from the array\n */\nconst peek = (a) => {\n  if (!a.length) {\n    return undefined;\n  }\n\n  return a[a.length - 1];\n};\n\n/**\n * Return the index for a given position in an unrolled 2d array\n * @param {number} x The x position\n * @param {number} y The y position\n * @param {number} w The width of the 2d array\n * @returns {number} The index in the unrolled array\n */\nconst ind = (x, y, w) => x + y * w;\n\n/**\n * Return the position for a given index in an unrolled 2d array\n * @param {number} i The index\n * @param {number} w The width of the 2d array\n * @returns {Array<number>} The position as a 2-tuple\n */\nconst pos = (i, w) => [i % w, Math.floor(i / w)];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\n/**\n * Flatten an object\n * @param {object} o\n * @param {string} concatenator The string to use for concatenating keys\n * @return {object} A flattened object\n */\nconst flat = (o, concatenator = '.') => {\n  return Object.keys(o).reduce((acc, key) => {\n    if (o[key] instanceof Date) {\n      return {\n        ...acc,\n        [key]: o[key].toISOString(),\n      };\n    }\n\n    if (typeof o[key] !== 'object' || !o[key]) {\n      return {\n        ...acc,\n        [key]: o[key],\n      };\n    }\n    const flattened = flat(o[key], concatenator);\n\n    return {\n      ...acc,\n      ...Object.keys(flattened).reduce(\n        (childAcc, childKey) => ({\n          ...childAcc,\n          [`${key}${concatenator}${childKey}`]: flattened[childKey],\n        }),\n        {}\n      ),\n    };\n  }, {});\n};\n\n/**\n * Unflatten an object\n * @param {object} o\n * @param {string} concatenator The string to check for in concatenated keys\n * @return {object} An un-flattened object\n */\nconst unflat = (o, concatenator = '.') => {\n  let result = {}, temp, substrings, property, i;\n\n  for (property in o) {\n    substrings = property.split(concatenator);\n    temp = result;\n    for (i = 0; i < substrings.length - 1; i++) {\n      if (!(substrings[i] in temp)) {\n        if (isFinite(substrings[i + 1])) {\n          temp[substrings[i]] = [];\n        } else {\n          temp[substrings[i]] = {};\n        }\n      }\n      temp = temp[substrings[i]];\n    }\n    temp[substrings[substrings.length - 1]] = o[property];\n  }\n\n  return result;\n};\n\n/**\n * A split predicate\n * @callback SplitPredicate\n * @param {any} value The current value\n * @return {boolean} True if the array should split at this index\n */\n\n/**\n * Split an array into sub-arrays based on a predicate\n * @param {Array<*>} array\n * @param {SplitPredicate} predicate\n * @return {Array<Array<*>>} An array of arrays\n */\nconst split = (array, predicate) => {\n  const result = [];\n  let current = [];\n  for (const value of array) {\n    if (predicate(value)) {\n      if (current.length) {\n        result.push(current);\n      }\n      current = [value];\n    } else {\n      current.push(value);\n    }\n  }\n  result.push(current);\n\n  return result;\n};\n\n/**\n * Pluck keys from an object\n * @param {object} o\n * @param {...string} keys The keys to pluck from the object\n * @return {object} An object containing the plucked keys\n */\nconst pluck = (o, ...keys) => {\n  return keys.reduce(\n    (result, key) => Object.assign(result, { [key]: o[key] }),\n    {}\n  );\n};\n\n/**\n * Exclude keys from an object\n * @param {object} o\n * @param {...string} keys The keys to exclude from the object\n * @return {object} An object containing all keys except excluded keys\n */\nconst exclude = (o, ...keys) => {\n  return Object.fromEntries(\n    Object.entries(o).filter(([key]) => !keys.includes(key))\n  );\n};\n\nif (true) {\n  module.exports = {\n    memoize,\n    floatEquals,\n    clamp,\n    frac,\n    round,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    npr,\n    ncr,\n    permutations,\n    combinations,\n    cartesian,\n    times,\n    range,\n    zip,\n    at,\n    peek,\n    ind,\n    pos,\n    chunk,\n    shuffle,\n    flat,\n    unflat,\n    split,\n    pluck,\n    exclude,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/canvas-helpers/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/canvas-helpers/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.clearPatternCache = clearPatternCache;\nexports.withContext = withContext;\nexports.line = line;\nexports.cross = cross;\nexports.arrow = arrow;\nexports.circle = circle;\nexports.rectangle = rectangle;\nexports.polygon = polygon;\nexports.path = path;\nexports.grid = grid;\nexports.image = image;\nconst utils_1 = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\n// Pattern cache for performance optimization\n// WeakMap keyed by image source, with values being Maps keyed by repeat mode\nlet patternCache = new WeakMap();\n/**\n * Get or create a cached pattern for the given image and repeat mode\n */\nfunction getCachedPattern(context, image, repeatMode) {\n    // Check if we have any patterns cached for this image\n    let imagePatterns = patternCache.get(image);\n    if (!imagePatterns) {\n        imagePatterns = new Map();\n        patternCache.set(image, imagePatterns);\n    }\n    // Check if we have a pattern cached for this repeat mode\n    let pattern = imagePatterns.get(repeatMode);\n    if (!pattern) {\n        // Create and cache the pattern\n        const newPattern = context.createPattern(image, repeatMode);\n        if (newPattern) {\n            imagePatterns.set(repeatMode, newPattern);\n            pattern = newPattern;\n        }\n    }\n    return pattern || null;\n}\n/**\n * Clear the pattern cache for a specific image, or clear the entire cache\n * if no image is specified. Useful for memory management.\n */\nfunction clearPatternCache(image) {\n    if (image) {\n        patternCache.delete(image);\n    }\n    else {\n        patternCache = new WeakMap();\n    }\n}\nconst DEFAULT_STYLE_OPTIONS = {\n    batch: false,\n    fill: false,\n    fillColor: null,\n    gradient: null,\n    stroke: true,\n    strokeColor: null,\n    lineWidth: 1,\n    lineStyle: 'solid',\n    lineDash: null,\n    crossStyle: 'x',\n    rounded: false,\n    arrow: {\n        type: 'caret',\n        size: 5,\n    },\n    pathType: 'linear',\n    bezierOrder: 3,\n    catmullRomTension: 0.5,\n    rectangleAnchor: 'top-left',\n};\nconst DEFAULT_LINE_DASHES = {\n    solid: [],\n    dashed: [5, 5],\n    dotted: [1, 3],\n};\nconst DEFAULT_IMAGE_OPTIONS = {\n    fillMode: 'center',\n    clip: false,\n    repeatMode: 'no-repeat',\n    opacity: 1,\n    scale: 1,\n    offset: (0, vec_1.vec2)(0, 0),\n    offsetRelative: false,\n};\nconst DEFAULT_GRID_OPTIONS = {\n    cellSize: 10,\n};\nconst BEZIER_MATRICES = {\n    1: (0, vec_1.mat)(2, 2, [-1, 1, 1, 0]),\n    2: (0, vec_1.mat)(3, 3, [1, -2, 1, -2, 2, 0, 1, 0, 0]),\n    3: (0, vec_1.mat)(4, 4, [-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0]),\n};\nconst BEZIER_COEFFICIENTS = (t, order) => ({\n    1: [t, 1],\n    2: [t * t, t, 1],\n    3: [t * t * t, t * t, t, 1],\n}[order]);\nconst CATMULL_ROM_BASIS_FUNCTIONS = [\n    (t, tension) => -tension * Math.pow(t, 3) + 2 * tension * Math.pow(t, 2) - tension * t,\n    (t, tension) => (2 - tension) * Math.pow(t, 3) + (tension - 3) * Math.pow(t, 2) + 1,\n    (t, tension) => (tension - 2) * Math.pow(t, 3) +\n        (3 - 2 * tension) * Math.pow(t, 2) +\n        tension * t,\n    (t, tension) => tension * Math.pow(t, 3) - tension * Math.pow(t, 2),\n];\nconst CATMULL_ROM_BASIS_VECTOR = (t, tension) => CATMULL_ROM_BASIS_FUNCTIONS.map(f => f(t, tension));\n/**\n * Type guard to check if a value is a Color object\n */\nfunction isColorObject(color) {\n    return (typeof color === 'object' &&\n        'r' in color &&\n        'g' in color &&\n        'b' in color &&\n        (typeof color.a === 'number' || !('a' in color)));\n}\n/**\n * Convert a color object to a string in the format \"rgba(r, g, b, a)\"\n */\nfunction colourToString(color) {\n    var _a;\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${(_a = color.a) !== null && _a !== void 0 ? _a : 1})`;\n}\n/**\n * Prepare a color value (string or Color object) for use in styles\n */\nfunction prepareColor(color) {\n    if (typeof color === 'string') {\n        // Assume it's already a valid CSS color string\n        return color;\n    }\n    else if (isColorObject(color)) {\n        // Convert Color object to CSS color string\n        return colourToString(color);\n    }\n    // If it's neither, default to black\n    return 'black';\n}\n/**\n * Prepare a gradient for use in styles\n *\n * Returns a CanvasGradient object or null if no gradient is specified\n */\nfunction prepareGradient(context, style) {\n    if (!style) {\n        return null;\n    }\n    let gradient;\n    if (style.type === 'linear') {\n        gradient = context.createLinearGradient(style.start.x, style.start.y, style.end.x, style.end.y);\n    }\n    else {\n        gradient = context.createRadialGradient(style.start.x, style.start.y, 0, style.start.x, style.start.y, vec_1.vec2.len(vec_1.vec2.sub(style.end, style.start)) / 2);\n    }\n    for (const stop of style.colorStops) {\n        gradient.addColorStop(stop.position, prepareColor(stop.color));\n    }\n    return gradient;\n}\n/**\n * Get a complete style object with default values filled in\n */\nfunction getStyle(style) {\n    var _a;\n    return Object.assign({}, DEFAULT_STYLE_OPTIONS, {\n        ...(style !== null && style !== void 0 ? style : {}),\n        lineDash: style && style.lineDash !== undefined\n            ? style.lineDash\n            : (style === null || style === void 0 ? void 0 : style.lineStyle) === undefined\n                ? []\n                : DEFAULT_LINE_DASHES[(_a = style.lineStyle) !== null && _a !== void 0 ? _a : 'solid'],\n        image: style && style.image !== undefined ? style.image : DEFAULT_IMAGE_OPTIONS,\n        grid: style && style.grid !== undefined ? style.grid : DEFAULT_GRID_OPTIONS,\n    });\n}\n/**\n * Pass in a context and some number of functions that take a context as their\n * first argument, and return an array of functions that don't require the\n * context argument\n *\n * If only one function is passed, this will return a single function\n */\nfunction withContext(context, ...functions) {\n    const result = functions.map(f => {\n        return (...args) => {\n            f(context, ...args);\n        };\n    });\n    return result.length === 1 ? result[0] : result;\n}\n/**\n * Draw a straight line segment between two points\n */\nfunction line(context, start, end, style) {\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple lines in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    context.moveTo(start.x, start.y);\n    context.lineTo(end.x, end.y);\n    // Stroke the path if required\n    // Additionally, if this is a batch operation, we don't stroke right away so\n    // that we can add more lines to the same path if we want\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a cross at a given position with a specified size\n */\nfunction cross(context, position, size, style) {\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple lines in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Draw the cross\n    const halfSize = size / 2;\n    if (actualStyle.crossStyle === '+') {\n        // Plus sign cross\n        context.moveTo(position.x - halfSize, position.y);\n        context.lineTo(position.x + halfSize, position.y);\n        context.moveTo(position.x, position.y - halfSize);\n        context.lineTo(position.x, position.y + halfSize);\n    }\n    else if (actualStyle.crossStyle === 'x') {\n        // X cross\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n    }\n    // Stroke the path if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw an arrow from a start point to an end point with an optional arrowhead\n * at the end\n *\n * This function does not support batch drawing since it requires\n * beginning a new path for the arrowhead\n */\nfunction arrow(context, start, end, style) {\n    var _a, _b;\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // Arrows don't support batch drawing since we have to begin a new path\n    // when drawing the arrowhead\n    context.beginPath();\n    // Draw the line segment\n    context.moveTo(start.x, start.y);\n    context.lineTo(end.x, end.y);\n    context.stroke();\n    // Draw the arrowhead if specified\n    if (actualStyle.arrow) {\n        const arrowSize = (_a = actualStyle.arrow.size) !== null && _a !== void 0 ? _a : 10;\n        const halfSize = arrowSize / 2;\n        const angle = vec_1.vec2.rad(vec_1.vec2.sub(end, start));\n        const arrowType = (_b = actualStyle.arrow.type) !== null && _b !== void 0 ? _b : 'caret';\n        context.save();\n        context.translate(end.x, end.y);\n        context.rotate(angle);\n        if (typeof arrowType === 'function') {\n            arrowType(context, arrowSize);\n        }\n        else if (arrowType === 'caret') {\n            if (actualStyle.strokeColor !== null) {\n                context.fillStyle = prepareColor(actualStyle.strokeColor);\n            }\n            context.beginPath();\n            context.moveTo(0, -halfSize);\n            context.lineTo(arrowSize, 0);\n            context.lineTo(0, halfSize);\n            context.closePath();\n            context.fill();\n        }\n        else if (arrowType === 'chevron') {\n            context.beginPath();\n            context.moveTo(-halfSize, -halfSize);\n            context.lineTo(0, 0);\n            context.lineTo(-halfSize, halfSize);\n            context.stroke();\n        }\n        context.restore();\n    }\n    context.restore();\n}\n/**\n * Draw a circle at a specified center point with a given radius\n */\nfunction circle(context, center, radius, style) {\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.fillColor !== null) {\n        context.fillStyle = prepareColor(actualStyle.fillColor);\n    }\n    if (actualStyle.gradient) {\n        const gradient = prepareGradient(context, actualStyle.gradient);\n        if (gradient) {\n            context.fillStyle = gradient;\n        }\n    }\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple shapes in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Draw the circle\n    context.arc(center.x, center.y, radius, 0, Math.PI * 2);\n    // Fill the circle if required\n    if (actualStyle.fill && !actualStyle.batch) {\n        context.fill();\n    }\n    // Stroke the circle if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a rectangle at a specified position with a given size\n */\nfunction rectangle(context, position, size, style) {\n    var _a;\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.fillColor !== null) {\n        context.fillStyle = prepareColor(actualStyle.fillColor);\n    }\n    if (actualStyle.gradient) {\n        const gradient = prepareGradient(context, actualStyle.gradient);\n        if (gradient) {\n            context.fillStyle = gradient;\n        }\n    }\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple shapes in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Calculate anchor offset\n    let anchor = actualStyle.rectangleAnchor || 'top-left';\n    let offsetX = 0, offsetY = 0;\n    switch (anchor) {\n        case 'top-left':\n            offsetX = 0;\n            offsetY = 0;\n            break;\n        case 'top-center':\n            offsetX = -size.x / 2;\n            offsetY = 0;\n            break;\n        case 'top-right':\n            offsetX = -size.x;\n            offsetY = 0;\n            break;\n        case 'center-left':\n            offsetX = 0;\n            offsetY = -size.y / 2;\n            break;\n        case 'center':\n            offsetX = -size.x / 2;\n            offsetY = -size.y / 2;\n            break;\n        case 'center-right':\n            offsetX = -size.x;\n            offsetY = -size.y / 2;\n            break;\n        case 'bottom-left':\n            offsetX = 0;\n            offsetY = -size.y;\n            break;\n        case 'bottom-center':\n            offsetX = -size.x / 2;\n            offsetY = -size.y;\n            break;\n        case 'bottom-right':\n            offsetX = -size.x;\n            offsetY = -size.y;\n            break;\n    }\n    const actualX = position.x + offsetX;\n    const actualY = position.y + offsetY;\n    // Draw the rectangle\n    if (actualStyle.rounded) {\n        context.roundRect(actualX, actualY, size.x, size.y, (_a = actualStyle.borderRadius) !== null && _a !== void 0 ? _a : 1);\n    }\n    else {\n        context.rect(actualX, actualY, size.x, size.y);\n    }\n    // Fill the rectangle if required\n    if (actualStyle.fill && !actualStyle.batch) {\n        context.fill();\n    }\n    // Stroke the rectangle if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a polygon defined by an array of vertices\n */\nfunction polygon(context, vertices, style) {\n    if (vertices.length < 3) {\n        return;\n    }\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.fillColor !== null) {\n        context.fillStyle = prepareColor(actualStyle.fillColor);\n    }\n    if (actualStyle.gradient) {\n        const gradient = prepareGradient(context, actualStyle.gradient);\n        if (gradient) {\n            context.fillStyle = gradient;\n        }\n    }\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple shapes in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Draw the polygon path\n    context.moveTo(vertices[0].x, vertices[0].y);\n    for (let i = 1; i < vertices.length; i++) {\n        context.lineTo(vertices[i].x, vertices[i].y);\n    }\n    context.closePath();\n    // Fill the rectangle if required\n    if (actualStyle.fill && !actualStyle.batch) {\n        context.fill();\n    }\n    // Stroke the rectangle if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a path defined by an array of vertices\n */\nfunction path(context, vertices, style) {\n    var _a, _b;\n    if (vertices.length < 2)\n        return;\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Handle different path types\n    const pathType = actualStyle.pathType || 'linear';\n    if (pathType === 'linear') {\n        // Simple linear path\n        context.moveTo(vertices[0].x, vertices[0].y);\n        for (let i = 1; i < vertices.length; i++) {\n            context.lineTo(vertices[i].x, vertices[i].y);\n        }\n    }\n    else if (pathType === 'bezier') {\n        const order = (0, utils_1.clamp)((_a = actualStyle.bezierOrder) !== null && _a !== void 0 ? _a : 3, 1, 3);\n        // Draw bezier curve segments\n        const segmentSize = order + 1;\n        for (let i = 0; i + segmentSize <= vertices.length; i += order) {\n            const segmentPoints = vertices.slice(i, i + segmentSize);\n            // Draw first point of segment\n            if (i === 0) {\n                context.moveTo(segmentPoints[0].x, segmentPoints[0].y);\n            }\n            // Draw bezier curve through points\n            for (let t = 0; t <= 1; t += 0.01) {\n                const q = vec_1.mat.mulv(BEZIER_MATRICES[order], BEZIER_COEFFICIENTS(t, order));\n                if (q === false) {\n                    context.restore();\n                    return;\n                }\n                let p = (0, vec_1.vec2)();\n                for (let j = 0; j < segmentSize; j++) {\n                    p.x += segmentPoints[j].x * q[j];\n                    p.y += segmentPoints[j].y * q[j];\n                }\n                context.lineTo(p.x, p.y);\n            }\n        }\n    }\n    else if (pathType === 'catmull-rom') {\n        const tension = (_b = actualStyle.catmullRomTension) !== null && _b !== void 0 ? _b : 0.5;\n        // Need at least 4 points for Catmull-Rom\n        if (vertices.length >= 4) {\n            context.moveTo(vertices[1].x, vertices[1].y);\n            // Draw curve segments\n            for (let i = 1; i < vertices.length - 2; i++) {\n                const points = [\n                    vertices[i - 1],\n                    vertices[i],\n                    vertices[i + 1],\n                    vertices[i + 2],\n                ];\n                for (let t = 0; t <= 1; t += 0.01) {\n                    const x = (0, utils_1.dot)(points.map(p => p.x), CATMULL_ROM_BASIS_VECTOR(t, tension));\n                    const y = (0, utils_1.dot)(points.map(p => p.y), CATMULL_ROM_BASIS_VECTOR(t, tension));\n                    context.lineTo(x, y);\n                }\n            }\n        }\n        else {\n            // Fall back to linear if not enough points\n            context.moveTo(vertices[0].x, vertices[0].y);\n            for (let i = 1; i < vertices.length; i++) {\n                context.lineTo(vertices[i].x, vertices[i].y);\n            }\n        }\n    }\n    // Stroke the path if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a grid of lines within a specified rectangular area\n */\nfunction grid(context, position, size, style) {\n    // Get merged style options\n    const actualStyle = getStyle(style);\n    const gridOptions = actualStyle.grid;\n    // Get cell size as vec2\n    const cellSize = typeof gridOptions.cellSize === 'number'\n        ? (0, vec_1.vec2)(gridOptions.cellSize, gridOptions.cellSize)\n        : gridOptions.cellSize;\n    context.save();\n    // Apply line styles\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // Begin path if not batching\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Draw vertical lines\n    const numVerticalLines = Math.floor(size.x / cellSize.x) + 1;\n    for (let i = 0; i <= numVerticalLines; i++) {\n        const x = position.x + i * cellSize.x;\n        if (x <= position.x + size.x) {\n            context.moveTo(x, position.y);\n            context.lineTo(x, position.y + size.y);\n        }\n    }\n    // Draw horizontal lines\n    const numHorizontalLines = Math.floor(size.y / cellSize.y) + 1;\n    for (let i = 0; i <= numHorizontalLines; i++) {\n        const y = position.y + i * cellSize.y;\n        if (y <= position.y + size.y) {\n            context.moveTo(position.x, y);\n            context.lineTo(position.x + size.x, y);\n        }\n    }\n    // Stroke the grid if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw an image at a specified position, optionally scaling it to fit within\n * a given rectangle\n */\nfunction image(context, image, position, size, style) {\n    var _a, _b, _c, _d, _e;\n    // Get merged style options\n    const actualStyle = getStyle(style);\n    const imageOptions = {\n        ...DEFAULT_IMAGE_OPTIONS,\n        ...((_a = actualStyle.image) !== null && _a !== void 0 ? _a : {}),\n    };\n    // Get natural image size\n    let imageWidth, imageHeight;\n    if ('width' in image && 'height' in image) {\n        imageWidth = image.width;\n        imageHeight = image.height;\n    }\n    else {\n        throw new Error('Cannot determine image size');\n    }\n    // Rectangle to draw in\n    const rectangleWidth = (_b = size === null || size === void 0 ? void 0 : size.x) !== null && _b !== void 0 ? _b : imageWidth;\n    const rectangleHeight = (_c = size === null || size === void 0 ? void 0 : size.y) !== null && _c !== void 0 ? _c : imageHeight;\n    let dx = position.x, dy = position.y;\n    // Compute draw size and position based on fillMode\n    let sx = 0, sy = 0, sw = imageWidth, sh = imageHeight;\n    let dw = imageWidth, dh = imageHeight;\n    // Compute scale for fill modes\n    switch (imageOptions.fillMode) {\n        case 'stretch':\n            dw = rectangleWidth;\n            dh = rectangleHeight;\n            break;\n        case 'contain': {\n            const scale = Math.min(rectangleWidth / imageWidth, rectangleHeight / imageHeight);\n            dw = imageWidth * scale;\n            dh = imageHeight * scale;\n            break;\n        }\n        case 'fill': {\n            const scale = Math.max(rectangleWidth / imageWidth, rectangleHeight / imageHeight);\n            dw = imageWidth * scale;\n            dh = imageHeight * scale;\n            break;\n        }\n        case 'fit-x': {\n            const scale = rectangleWidth / imageWidth;\n            dw = imageWidth * scale;\n            dh = imageHeight * scale;\n            break;\n        }\n        case 'fit-y': {\n            const scale = rectangleHeight / imageHeight;\n            dw = imageWidth * scale;\n            dh = imageHeight * scale;\n            break;\n        }\n        case 'center':\n        default:\n            dw = imageWidth;\n            dh = imageHeight;\n            break;\n    }\n    // Apply scale option\n    if (imageOptions.scale) {\n        if (typeof imageOptions.scale === 'number') {\n            dw *= imageOptions.scale;\n            dh *= imageOptions.scale;\n        }\n        else {\n            dw *= imageOptions.scale.x;\n            dh *= imageOptions.scale.y;\n        }\n    }\n    // Center image in rect for 'center', 'contain', 'fit-x', 'fit-y'\n    if (imageOptions.fillMode !== 'stretch') {\n        dx += (rectangleWidth - dw) / 2;\n        dy += (rectangleHeight - dh) / 2;\n    }\n    // Apply offset\n    if (imageOptions.offset) {\n        if (imageOptions.offsetRelative) {\n            dx += imageOptions.offset.x * rectangleWidth;\n            dy += imageOptions.offset.y * rectangleHeight;\n        }\n        else {\n            dx += imageOptions.offset.x;\n            dy += imageOptions.offset.y;\n        }\n    }\n    context.save();\n    if (imageOptions.opacity !== undefined && imageOptions.opacity < 1) {\n        context.globalAlpha *= imageOptions.opacity;\n    }\n    // Draw background rectangle if fill or stroke is requested\n    if ((actualStyle.fill || actualStyle.stroke) &&\n        (actualStyle.fillColor !== null || actualStyle.strokeColor !== null)) {\n        // Only override anchor to top-left for background\n        const rectStyle = {\n            ...actualStyle,\n            rectangleAnchor: 'top-left',\n        };\n        rectangle(context, { x: dx, y: dy }, { x: dw, y: dh }, rectStyle);\n    }\n    // Clip if requested\n    if (imageOptions.clip && size) {\n        context.beginPath();\n        // Support rounded corners if style.rounded and style.borderRadius is set\n        const rounded = (_d = actualStyle.rounded) !== null && _d !== void 0 ? _d : false;\n        const borderRadius = (_e = actualStyle.borderRadius) !== null && _e !== void 0 ? _e : 0;\n        if (rounded && borderRadius > 0) {\n            context.roundRect(position.x, position.y, rectangleWidth, rectangleHeight, borderRadius);\n        }\n        else {\n            context.rect(position.x, position.y, rectangleWidth, rectangleHeight);\n        }\n        context.clip();\n    }\n    // Handle repeat modes\n    if (imageOptions.repeatMode &&\n        imageOptions.repeatMode !== 'no-repeat' &&\n        size) {\n        // Use cached pattern for better performance\n        const pattern = getCachedPattern(context, image, imageOptions.repeatMode);\n        if (pattern) {\n            context.save();\n            // Calculate the scale factors\n            const scaleX = dw / imageWidth;\n            const scaleY = dh / imageHeight;\n            // Apply transformation: translate to pattern origin, then scale\n            context.translate(dx, dy);\n            context.scale(scaleX, scaleY);\n            context.fillStyle = pattern;\n            // Fill the rectangle in the scaled coordinate system\n            // We need to divide by the scale to get back to pattern coordinates\n            const patternWidth = rectangleWidth / scaleX;\n            const patternHeight = rectangleHeight / scaleY;\n            const patternX = (position.x - dx) / scaleX;\n            const patternY = (position.y - dy) / scaleY;\n            context.fillRect(patternX, patternY, patternWidth, patternHeight);\n            context.restore();\n        }\n    }\n    else {\n        // Draw the image\n        context.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\n    }\n    context.restore();\n}\n\n\n//# sourceURL=webpack://@basementuniverse/canvas-helpers/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});